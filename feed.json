{
    "version": "https://jsonfeed.org/version/1",
    "title": "Zaoei Blog Blog",
    "home_page_url": "https://blog.palashsh.me/",
    "description": "Zaoei Blog Blog",
    "items": [
        {
            "id": "https://blog.palashsh.me/tools-select-option",
            "content_html": "<p>如果想调试搜索框选中下拉元素的样式。</p>\n<p>当切到 <code>Element</code>，搜索框下边的内容就会消失掉</p>\n<p>此时找到 <code>MoreTools</code>，<code>Rendering</code>，开启 <code>Emulate a focused page</code> 配置，此时下拉框就不会消失了\n<img alt=\"Alt text\" src=\"https://blog.palashsh.me/assets/images/image-0e957458212f4385cf3ed7afaa763970.png\" width=\"2856\" height=\"1512\"></p>",
            "url": "https://blog.palashsh.me/tools-select-option",
            "title": "浏览器调试下拉option的方法",
            "summary": "如果想调试搜索框选中下拉元素的样式。",
            "date_modified": "2024-02-06T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "tools"
            ]
        },
        {
            "id": "https://blog.palashsh.me/python environment",
            "content_html": "<h2 id=\"背景\">背景</h2>\n<p>帮助文档的 <code>pdf</code> 和 <code>word</code> 导出，基于 <code>python</code> 生成，所以需要在服务器上搭建相应的环境。</p>\n<h2 id=\"pandoc\">pandoc</h2>\n<p><code>Pandoc</code> 是一个用于文本转换的开源工具，可以将一个文档从一种格式转换为另一种格式。它支持的输入格式包括 <code>Markdown</code>、<code>HTML</code>、<code>LaTeX</code> 和 <code>docx</code> 等，输出格式包括 <code>HTML</code>、<code>LaTeX</code>、<code>docx</code>、<code>PDF</code> 等。\n下载地址：<a href=\"https://github.com/jgm/pandoc/releases\">https://github.com/jgm/pandoc/releases</a>\n这里下载的是 <code>pandoc-3.1.4-linux-amd64.tar.gz</code></p>\n<pre><code class=\"language-shell\">mkdir -p /opt/pandoc\ncd /opt/pandoc\n# 上传压缩包\ntar -xvf pandoc-3.1.4-linux-amd64.tar.gz\nln -sf /opt/pandoc/pandoc-3.1.4/bin/pandoc /usr/bin/pandoc\npandoc -v\n</code></pre>\n<h2 id=\"ruby\">Ruby</h2>\n<p><code>Ruby</code> 是一种动态、面向对象的编程语言。<code>asciidoctor</code> 依赖它。</p>\n<h3 id=\"离线安装推荐\">离线安装（推荐）</h3>\n<p>安装包下载地址（下载 2.7 以上版本）：<a href=\"https://www.ruby-lang.org/en/downloads/releases/\">https://www.ruby-lang.org/en/downloads/releases/</a></p>\n<pre><code class=\"language-shell\">mkdir -p /opt/ruby\ncd /opt/ruby/\n// 上传安装包\ntar -zvxf ruby-2.7.7.tar.gz\ncd ruby-2.7.7\n\n// 进行编译安装\n./configure --prefix=/usr/local/ruby\nmake &amp;&amp; make install\n\n// 建立软链，覆盖系统默认的 2.0 ruby 版本\nln -sf /usr/local/ruby/bin/ruby /usr/bin/ruby\n</code></pre>\n<h3 id=\"在线安装\">在线安装</h3>\n<p>先确认是否安装了 <code>rvm</code>，<code>rvm</code> 是用来管理 <code>ruby</code> 版本的工具。</p>\n<h4 id=\"rvm\">rvm</h4>\n<pre><code class=\"language-shell\"># 下载 gpg 公钥\n\ngpg2 --keyserver hkp://keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\ncurl -L get.rvm.io | bash -s stable\nln -sf /usr/local/rvm/bin/rvm /usr/bin/rvm\nrvm -v\n</code></pre>\n<h4 id=\"安装升级-ruby\">安装/升级 ruby</h4>\n<pre><code class=\"language-shell\">rvm install ruby // 安装最新版本\n\nrvm install 2.7.2 // 安装指定版本的\n</code></pre>\n<h4 id=\"升级报错\">升级报错</h4>\n<pre><code class=\"language-shell\">[root@172-16-82-102 ~]# rvm install 2.7.1\nAlready installed ruby-2.7.1.\nTo reinstall use:\n\n    rvm reinstall ruby-2.7.1\n\n-bash: cat: 未找到命令\n</code></pre>\n<p>安装导致环境变量被覆盖，导致 <code>/usr/bin/</code>环境变量缺失。\n加入 <code>/usr/bin/</code> 的信息恢复正常。</p>\n<pre><code class=\"language-shell\">export PATH=$PATH:/usr/bin/\n</code></pre>\n<h2 id=\"asciidoctor\">asciidoctor</h2>\n<p><code>Asciidoctor</code> 是一个用于文本转换的开源工具，可以将一个文档从 <code>Asciidoc</code> 格式转换为 <code>HTML</code>、<code>PDF</code>、<code>ePub</code> 和其他格式。<code>Asciidoctor</code> 是 <code>Ruby</code> 编写的</p>\n<pre><code class=\"language-shell\">gem install asciidoctor\n</code></pre>\n<h2 id=\"asciidoctor-pdf\">asciidoctor-pdf</h2>\n<p><code>Asciidoctor PDF</code> 是 <code>Asciidoctor</code> 的一个插件，可以将 <code>Asciidoc</code> 文档转换为 <code>PDF</code> 格式。</p>\n<pre><code class=\"language-shell\">ruby version ≥ 2.7\ngem install asciidoctor-pdf\n</code></pre>\n<h3 id=\"安装后找不到\">安装后找不到</h3>\n<p>报错如下：</p>\n<pre><code class=\"language-shell\">[root@172-16-82-102 ~]# asciidoctor-pdf -v\n-bash: asciidoctor-pdf: 未找到命令\n</code></pre>\n<p>可采用 gem which 查看安装地址，建立软链</p>\n<pre><code class=\"language-shell\">\n[root@172-16-82-102 ~]# gem which asciidoctor-pdf\n/usr/local/ruby/lib/ruby/gems/2.7.0/gems/asciidoctor-pdf-2.3.8/lib/asciidoctor-pdf.rb\n\n[root@172-16-82-102 ~]# ln -sf /usr/local/ruby/lib/ruby/gems/2.7.0/gems/asciidoctor-pdf-2.3.8/bin/asciidoctor-pdf /usr/bin/asciidoctor-pdf\n</code></pre>\n<h2 id=\"python3\">python3</h2>\n<p><code>python2</code> 与 <code>python3</code> 存在语法差异，使用 <code>python2</code> 执行会报以下错误，且 <code>python2</code> 官方不在维护，</p>\n<pre><code class=\"language-shell\">File \"./convert2adoc/convert2adoc.py\", line 40\nSyntaxError: Non-ASCII character '\\xef' in file ./convert2adoc/convert2adoc.py on line 40, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details\n</code></pre>\n<h3 id=\"离线安装-python3\">离线安装 python3</h3>\n<pre><code class=\"language-shell\">// 下载 python3\nmkdir -p /opt/python3\ncd /opt/python3/\nwget https://www.python.org/ftp/python/3.9.5/Python-3.9.5.tar.xz\ntar -xvf Python-3.9.5.tar.xz\ncd Python-3.9.5/\n\n// 安装\n./configure --prefix=/usr/local/python3\nmake &amp;&amp; make install\n\n// 增加 python3 的软连接\nln -sf /usr/local/python3/bin/python3.9 /usr/bin/python3\nln -sf /usr/local/python3/bin/python3.9-config /usr/bin/python-config\n</code></pre>\n<h2 id=\"pip\">pip</h2>\n<pre><code class=\"language-shell\">// 增加 pip 的软连接\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip\n</code></pre>\n<h3 id=\"切换国内源\">切换国内源</h3>\n<pre><code class=\"language-shell\">mkdir -p ~/.pip\nvim ~/.pip/pip.conf\n</code></pre>\n<p>写入内容：</p>\n<pre><code class=\"language-shell\">[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host = mirrors.aliyun.com\n</code></pre>\n<h3 id=\"安装报错\">安装报错</h3>\n<p>提示以<code>“root”</code>用户身份运行 <code>pip</code> 可能会导致权限损坏和冲突，</p>\n<pre><code class=\"language-shell\">WARNING: Running pip as the ‘root‘ user can result in broken permissions and conflicting\n</code></pre>\n<p>解决方案是建立一个虚拟环境:</p>\n<pre><code class=\"language-shell\">[root@172-16-82-102 jm]# pip -V\npip 23.1.2 from /usr/local/python3/lib/python3.9/site-packages/pip (python 3.9)\n[root@172-16-82-102 jm]# cd /usr/local/python3/lib/python3.9/site-packages/pip # 进入安装地址\n[root@172-16-82-102 pip]# python -m venv tutorial-env\n[root@172-16-82-102 pip]# source tutorial-env/bin/activate\n(tutorial-env) [root@172-16-82-102 pip]#\n</code></pre>\n<p>安装参考：</p>\n<pre><code class=\"language-shell\">(tutorial-env) [root@172-16-82-102 pip]# pip install pyyaml\nLooking in indexes: http://mirrors.aliyun.com/pypi/simple/\nRequirement already satisfied: pyyaml in ./tutorial-env/lib/python3.9/site-packages (6.0)\n(tutorial-env) [root@172-16-82-102 pip]# pip install esprima\nLooking in indexes: http://mirrors.aliyun.com/pypi/simple/\nCollecting esprima\nUsing cached esprima-4.0.1-py3-none-any.whl\nInstalling collected packages: esprima\n</code></pre>\n<p>二次进入虚拟环境\n先进入 pip 安装路径，再进入</p>\n<pre><code class=\"language-shell\">[root@172-16-82-102 ~]# cd /usr/local/python3/lib/python3.9/site-packages/pip\n[root@172-16-82-102 pip]# source tutorial-env/bin/activate\n</code></pre>\n<h3 id=\"安装-yaml\">安装 yaml</h3>\n<p>需先进入虚拟环境</p>\n<pre><code class=\"language-shell\">pip install yaml\n</code></pre>\n<h3 id=\"安装-esprima\">安装 esprima</h3>\n<p>需先进入虚拟环境</p>\n<pre><code class=\"language-shell\">pip install esprima\n</code></pre>",
            "url": "https://blog.palashsh.me/python environment",
            "title": "搭建 python 环境",
            "summary": "背景",
            "date_modified": "2023-06-23T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "linux",
                "python"
            ]
        },
        {
            "id": "https://blog.palashsh.me/resize",
            "content_html": "<p>MDN 地址：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\">https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver</a></p>\n<p>ResizeObserver 接口监视 Element 内容区域或者 SVGElement 边界尺寸的变化。</p>\n<h1 id=\"用法\">用法</h1>\n<h2 id=\"构造函数\"><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver/ResizeObserver\">构造函数</a></h2>\n<p>ResizeObserver 构造函数创建一个新的 ResizeObserver 对象，它可以用于监听 Element 内容盒或边框盒或者 SVGElement 边界尺寸的大小。</p>\n<pre><code class=\"language-js\">new ResizeObserver(callback);\n</code></pre>\n<h3 id=\"callback\">callback</h3>\n<p>每当观测的元素调整大小时，调用该函数。该函数接收两个参数：</p>\n<ul>\n<li>entries: 一个 ResizeObserverEntry 对象数组，可以用于获取每个元素改变后的新尺寸。</li>\n<li>observer: 对 ResizeObserver 自身的引用，因此需要它的时候，你要从回调函数的内部访问。例如，这可用于在达到特定的情况时，自动取消对观察者的监听，但如果你不需要它，可以省略它。</li>\n</ul>\n<h2 id=\"实例方法\">实例方法</h2>\n<h3 id=\"disconnect\">disconnect</h3>\n<p>取消当前 resizeObserver 上，所有 DOM 元素的监听</p>\n<pre><code class=\"language-js\">resizeObserver.disconnect();\n</code></pre>\n<h3 id=\"observe\">observe</h3>\n<p>用于监听指定的 Element 或 SVGElement</p>\n<pre><code class=\"language-js\">observe(target);\nobserve(target, options);\n</code></pre>\n<ul>\n<li>target: 需要监听的元素</li>\n</ul>\n<h3 id=\"unobserve\">unobserve</h3>\n<p>取消指定 Element 或 SVGElement 的监听</p>\n<pre><code class=\"language-js\">unobserve(target);\n</code></pre>\n<h2 id=\"mdn-例子片段\">MDN 例子片段</h2>\n<pre><code class=\"language-js\">const resizeObserver = new ResizeObserver((entries) =&gt; {\n  for (let entry of entries) {\n    if (entry.contentBoxSize) {\n      h1Elem.style.fontSize = `${Math.max(1.5, entry.contentBoxSize.inlineSize / 200)}rem`;\n      pElem.style.fontSize = `${Math.max(1, entry.contentBoxSize.inlineSize / 600)}rem`;\n    } else {\n      h1Elem.style.fontSize = `${Math.max(1.5, entry.contentRect.width / 200)}rem`;\n      pElem.style.fontSize = `${Math.max(1, entry.contentRect.width / 600)}rem`;\n    }\n  }\n});\n\nresizeObserver.observe(divElem);\n\nresizeObserver.unobserve(divElem);\n</code></pre>",
            "url": "https://blog.palashsh.me/resize",
            "title": "ResizeObserver",
            "summary": "MDN 地址：https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver",
            "date_modified": "2023-05-25T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "js",
                "ResizeObserver",
                "resize"
            ]
        },
        {
            "id": "https://blog.palashsh.me/utils web",
            "content_html": "<p>查询浏览器 API 兼容情况</p>\n<ul>\n<li><a href=\"https://caniuse.com/\">https://caniuse.com/</a>: 查询浏览器 API 兼容情况\n<img src=\"https://blog.palashsh.me/assets/images/caniuse-example-2818d13fde79799fa42fbd7cb59906a5.png\" width=\"1179\" height=\"561\"></li>\n</ul>",
            "url": "https://blog.palashsh.me/utils web",
            "title": "https://caniuse.com",
            "summary": "查询浏览器 API 兼容情况",
            "date_modified": "2023-05-25T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "utils",
                "网站地址"
            ]
        },
        {
            "id": "https://blog.palashsh.me/Inspection Report",
            "content_html": "<p>巡检报告是指对某一个系统或设备进行全面检查，并把检查结果及建议整理成报告的过程。巡检报告通常用于评估系统或设备的运行状况与性能，以发现问题、优化系统、提高效率、降低故障率等方面提供参考。\n<img alt=\"总览\" src=\"https://blog.palashsh.me/assets/images/image-5b773468089c1941e75a69ba52be3763.png\" width=\"1500\" height=\"955\"></p>\n<h1 id=\"要实现什么功能\">要实现什么功能</h1>\n<p><img alt=\"巡检报告功能\" src=\"https://blog.palashsh.me/assets/images/%E5%B7%A1%E6%A3%80%E6%8A%A5%E5%91%8A-fbb74bd88fed89520baa5a1d394c0481.gif\" width=\"1794\" height=\"1062\"></p>\n<h3 id=\"1自定义布局\">1、自定义布局</h3>\n<ol>\n<li>现报告中的面板可进行拖拽改变布局。</li>\n<li>在拖拽的过程中限制拖拽区域，只允许在同一父级内进行拖拽，不允许跨目录移动，不允许改变目录的级别，比如把一级目录移动到另一个一级目录内，变成二级目录</li>\n</ol>\n<h3 id=\"2目录可收缩展开\">2、目录可收缩展开</h3>\n<ol>\n<li>目录支持收缩展开，收缩时隐藏所以子面板，展开时显示所以子面板</li>\n<li>移动目录时，子面板跟随移动</li>\n<li>改变目录后，同步更新右侧的目录面板</li>\n<li>生成目录编号</li>\n</ol>\n<p><img alt=\"image.png\" src=\"https://blog.palashsh.me/assets/images/image(1)-4f2f2f5e40e3615d779223916ad01bd5.png\" width=\"1036\" height=\"432\"></p>\n<h3 id=\"3右侧目录树\">3、右侧目录树</h3>\n<ol>\n<li>生成目录编号</li>\n<li>支持锚点滚动</li>\n<li>支持展开收缩</li>\n<li>与左侧报告联动</li>\n</ol>\n<p><img alt=\"image.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATIAAAC3CAIAAAAerkVNAAABYWlDQ1BJQ0MgUHJvZmlsZQAAKJF1kbFLAnEUx79XllAHNUQ0ONwg0WBhZ5GrWkTgIJZQbXfnpYWeP86LaAiCahdqaQtb+gtqaWhrioKgIULagraoHCr59X5epRa9H4/vhy/vPR7vB7TJGmM5D4C85djJ6agyv7CoeB/QCR9kDGFCM4oskkjEqQTf2hrVG0hCr4fFLPPp5XzD/3YhdT+uVLbs6N/6luhKm0WD9INSNZjtAFKQOLHmMMGbxH02LUW8Jzjj8pFg3eXTes1cMkZ8RdxrZLU08T1xQG/yM02cz60aXzuI7WXTSs2S9lP6MIkpxOkpSEHFOEYRJg//9IzVe2IogGEdNpaRQRYOdUfIYcjBJJ6BBQMjCBCrCFKGxK1/37DhFcpA+BVoLzU8fR842QEGbhue/wDo2QaOL5lmaz+Xlaqe4lJIdVmmf+iocP48CHh3gVqJ8/cy57VDmn8HnFmfffdlj9DoacMAAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAATKgAwAEAAAAAQAAALcAAAAAwFcEkgAAIdJJREFUeAHtnQm8TVX7x5ehZB5DpqTSYChjxoQSKkMZSgPiDZXXGEklxRslQ17yCv8GDRRpQJSkFGWWNMpUIZlJ5v93W9d22uc49zj33nOO7bc/93Pu2mvev71/63nWs895nnQ7/zpgdAgBIZBICKRPpMloLkJACDgIpDt27JiQEAJCIF4I7Np/MHhoSctgTJQjBOKMgGgZ5xug4YVAMAKiZTAmyhECcUZAtIzzDdDwQiAYAdEyGBPlCIE4IyBaxvkGaHghEIyAaBmMiXKEQJwREC3jfAM0vBAIRkC0DMZEOUIgzgiIlnG+ARpeCAQjIFoGY6IcIRBnBETLON8ADS8EghEQLYMxUY4QiDMComWcb4CGFwLBCIiWwZgoRwjEGYGMUYy/d+/eU7VKnz59lixZ3NItW7bs2bPHPXUT1ClUqJB7qoQQEAKBCETzM+iyZcsGduFJr1y50s3p0qXL3Llz3VM3Ubt27REjRrinSgiBsxaBkD+DjkZagmCNGjUaNWrkgXLmzJkeEj766KM9evTwVOvevbsnR6dCIDERCC+BguccKJOCSyPPiZKWxYoVq1q1qmeY1atXe3K2bdvWsWNHT+b27dsLFy7sydSpEEhABMaPHx+XWaWhEnvkyBEcBR06dMhzYe3atcubN+/w4cPJz5Ahg6dUp0LgrEIgNZXYevXqNWvWzAPftGnTZsyYYTO3bt1at25dT4XA03LlynE6e/bsggULBuYrLQSEQJRKbJEiRapUqeKBb9myZW5Ojhw52FiuWLGiVKlSGTM6o4wePRrra5MmTUjPmTMne/bslStXpprbRAkhkGgILFq0qFKlSu6sOB0zZox76klUrFixU6dOnszoTqOk5YIFC4I9WTJpdxKZMmWqVq3agAEDeJsyaNCgzJkzT5kypXjx4i1atJg/fz7NS5cu3bx583Tp0rlNlBACiYYAJOTAPuKSE+6dapJhik7V5FT5UdJyw4YNwS8kd+zYETgMEnXw4MG9e/fms2jRot8dP/Lnzz9hwgQ02JEjR4qTgXApnZgIIGw4EIMckNPlZ5rONkpatmzZsmvXrp6ZvXD8CMxs0KAByirrzdSpU20+nMyTJ8+oUaOyZcsWWFNpIZDICKSiJIzkMqOkZSRdHz16FAvQkCFD8uXL9/bbbz/22GMlS5YsU6YMmm2bNm369OlToUKFSPpRHSEQRwQQj4FKLKInzGSQqGFKIy+KkpaTJk2aN2+eZ5jNmze7Ob///nu3bt3QW9u3b89VYfWxSi97ywIFCvTr169t27b169cnkTVrVreVEkIgoRDwWHHQZhcvXnyqGaaiRI2SlrzVCLbELl26FB7aSefOnZvExIkT+Z4ECww05lsETZs2JbNWrVrTp0/nRe2SJUswBZ3qIpUvBOKOgEf6Hd9anjTMpt30ovk6ARop6mjw95JWrVq1Zs2axo0be6ZLJssMm8k6deoEfpEdLZevtnsq61QInFUIhPw6QTS0PKtQ08WezQiE30kGI+ORrsEVgnNEy2BMlCMEwiEQrBKGq21MFF9VFy3DQ6pSIRAHBELSUlu7ONwJDSkEwiMgWobHR6VCIA4IiJZxAF1DCoHwCIiW4fFRqRCIAwKiZRxA15BCIDwComV4fFQqBOKAgGgZB9A1pBAIj4BoGR4flQqBOCAgWsYBdA0pBMIjIFqGx0elQiAOCIiWcQBdQwqB8AiIluHxUakQiAMComUcQNeQQiA8AqdHS1yBcITvUaVCQAikEIHTo2UKB1NzISAEIkFAtIwEJdURAjFFQLSMKdwaTAhEgoBoGQlKqiMEYoqAaBlTuDWYEIgEAdEyEpRURwjEFIEo3Ten0RwX/mSmfJ3Ud5cGZvxcs3v/yaEGtDCZz006/XGTuWe06d/cFHbcRCcdlxcyGY+Hsd2+1/SdlJRZ6WLTqIJ5bHLSaaki5sEbnXTnl8wd1Uy1kk7609Xmg6VmQEvTbJh5vbN59n1Tu5SpU8op6veWKVPMNLvGSR87Zlq/YDZuM+/2NDnkd9qBREeaIBA7ackz3XOiWbYu3GWs3WrOzWjuvc78tt38ucfMWWXurG7a13b+YOzhI0ltf/nDIVXBnGbyAjNshvPXYZzzt/9gUoW/DppNO8yTzc0tFcw3G82+A0mnd9UwS9cm1bn/BvP4W+aNL53TVz4zNS437y8xF+Qyfx8yn3xrKpVIqhb4b+J8kzuraVvLPDklMFtpIZDKCMRIWn70jcOx+T+YBlcncwG5sjjcOO+cpGoIwCyZHJl55KjJmsnJnL3S9J9ial5uvvzRtKzmJAa+YwrnMc+3NtkDJNjWPWbgNLN1t8mf02llT3fuM+lPBNS8orB5o7P5ebNZt9X8sMnUv8oRlY80Ma9+7qTpasc+03q02bbXzF1tNu00RfOa178wk7ua7OeZzv/nSNHHbzMZYresOVeh4yxBIEa0hEt7/44I0mmLzax/Vu72qvn6Z3NLeWMDI5S90Ex8wCHJpAVmxEznDwk27j5TMNfJ/gvlNtN7JZ1CTmQvp+8tMUjjXrc4+cjV749/W6lEATPuE9Okoll2XIqWK24ees28/qBTh26n9TB1B5qbyzuSeeh0R5LXf9opYo0gp/urZkRr51SHEEhdBGJEy2fvdKZdvV/yk2e/x97vvheTasKlWlc4fxxw6cBh88kq89l3jmrKceNVpnRR89ZCc9swh0XVLzN1SxnE4P0TnFKOI8fM+q1mzRZH/LIu/LHb/PC7s2+sV8bZbSKEb7vGrNxo7qtjlq4zFUo4NeHehefb1o6cZFD673i9ebmTw/yVG8yVRUyGdGbzLvPrtqRq+icEUheBhFPC2Aeyqzx4OOkyR3/kbPkWrTGD3nW2iEePmpnLTclCZnAr83Ffk/kcZ8M5uYt55X7DvnHXX2bFBpP1PPNwY9O7kSmQy/yxyzzTyjzRzNQr63CSfP4aXu0Q74Nezi6Ro35ZRzEmc+63Bp0ZVfmrn5NGR2vFyITizW4TWxTGHhTmbUzviGk10tS4LKma/gmB1EUgRtIywkkfOOSomtOXnaTlvdc5ZLi7pvl2o8mX3emm+00ObVZtdP7YXqKgwkZ73FrJVC1pDh12totYcc7PYd7rmbThLFvM2WRiYsX0ihmJvah7NCxnxs11qIswnPedaVnVaXvNJU7Pv253JDDG2843Orou42KVxWqVN5u5tGCSUu32o4QQSC0EEktabt9nMJB+1s/AInvwbgOqQJubyiflYNGFvfwhtRCAyD17+vn35us1Tp0N2wwmUxj102bTdKizV0TjvX6gszlECMPkSQuTurL/CuQ0JfI78hBWo682qWSWr3dsPKi1vBdBX+XIk81RcZesNVcXdz6XrXcSOoRAGiEQN1pCm7FzHMkWePy5+x+WG4rYEzauaD7+5qQJt/xFhleaHa53iIdM63mzc8oftMF8ynFxAUetZYv4Tncz7G6zZZfDxssucE5RaEsXMf2bJY2Jtrz3+HtRyI+qjLLqbFmPOZtPJDYb2uZVkmryD2vQivWm8sWmZEEzb7W57sqTRUoJgdRFIG60/GWLmfCp2X/oH5eDuLsov5PDy0N7oMHOWuFw7PHJzhsLDraXvP1na8c3B4bclVQNEbp8nSkSoJpSgMSDk/ZwXl3udF6TmBMvSDDkzljuGHVGfOioqSixObM4G0643aexaXOt84UB3tbYA8MP70LJ540I/KTbfNmcdyc6hEBaIBDTveUX/U9ewrVXmIVPnTwlhV0U2XhhPnPvGMOXeCzHHvg/06q6ubuGeeZ90+s154UEeimWnrtqOjonr0ymLjIvfepYaBFivMN0DyQkWitcssf6P51Thsh7fIMKS0fNNi91ct6R8m0E3sFgp+W1h3tcWdhM6OiemQU/Oc3dA6svE0Oo9rjJzVNCCKQaAqcXDdq6JihUqFCqjf/Pjvbsd4QVFEJMIbt4mcEbSKuaUhGRhV0UScVu0D2wxO7528mH0oEHxC55gTl0xHmNgS0HyQbP6YEvGBTL51QkB8tNsgcimp7dL/0lW18VhMBpIRAyvmVi0fK0rkeVhYAPEAhJy7jtLX0AqC5BCKQRAqJlGgGrboVA9AiIltFjp5ZCII0QEC3TCFh1KwSiR0C0jB47tRQCaYSAaJlGwKpbIRA9AqJl9NippRBIIwREyzQCVt0KgegREC2jx04thUAaISBaphGw6lYIRI+AaBk9dmopBNIIAdEyjYBVt0IgegREy+ixsy337du3du3aAwcOpLQjtRcCJxBIXFoeO3bsiSeeWLVq1Ymp/uN/+FJbtWHDhm+//bbb7LvvvitbtuzOnTvdnPAJfsU2e/bsMHU2bNjQqlWrqlWrNm7cuFKlSu3bt9+8eXOY+qdV9MILLzz66KOn1USVfYNAgtLys88+Gzhw4NSpU0OyKHxp4L2BvYGnpINzPBXc059++mn48OHuqSexdevWli1bFi9efM6cOStXrpw5c2bGjBlvv/32v/464fDL0+A0Txs1atSuXbvTbKTqPkEgQWk5d+7cXbtOOPwIgjp8aVD1EBmffvpp06ZNEXRdunTZsmULNXbv3j148ODrrruO/Hnz5v3222+c/vrrr927dw/R3pi33norW7Zs/fr1O/98x6ts4cKFBw0atH379hkzZjz44IMffPCBbUXi4YcfJo3Yb9OmDf337dvXrjXTpk0bNWoUPfTp0wepu2bNcQdhxjz77LOvvvrqV1999fHHH9Pwzz//fOihh2jYoUOH77//nhzmDAIkWAvuuusuqz8/+eSTLBBk6vABAglKSx5Wns6sWbOGhDh8aWAT5OqEEwc0sEUQ4N///jecHDt27JEjR3r16oUIRTKzRRw9ejSqb+fOnbNnz37rrbfmyZPnX//6V2CHbhqa1apVK1Om4wEYjufmypWrcuXKv/zyS7Fixd5//31b85133kGibtu2DeJdfvnlzz33HMtN165dKUXe/u9//2NRYCHYv3+/ZRoJOElN9OF169YxMabKkgHnr7zyyhYtWuzZs4eBvvjiC3pg+UBQo5wfPHgQdf3CCy+0g+rzTEcgpr58Yg8WTzbEs+PycNvE9OnT2WTCRk579OjBzhAOIB537Nhx7rnnskWsWLEiiUsvvTRLlixXXHFFyGnDtMsu8/pvRo9FiW3SpMk999zDcIcOHVq0aNFjjz2GWCtQoEDv3r3TpUuXN29eFFRkIN1CexaC9OnT33zzzexjGXrBggVkVqhQgYZUgHLw/8MPP8RRyzXXXAPJkaIsKIhZShcuXMj0VqxYQQ+0uvjii0NOVZlnHAI+pyX0aN68ub0rPOLsBklv3LjxqquuspnWLxGEhBIQFQlZpEiRu+++u1y5cuHvZcGCBS1z3GqQ8Msvv0SDhfOQkPTff/8NbZCWb7zxBlLRHZQmVo+tUqUKjOL0hhtuGDFiBHVQRGG1zSQfLZrP+vXr82kP9OQ6deqsX7/eGsPuuOMOxCxCFS0Xzp+opf9nNgI+p2XIm4MYtJs0SrGm8nnJJZeQGDNmDGzhKX/66acRTSHbupllypR5/vnnqY9KaTMtTxB0kOqWW25h+7p37144RikqcenSpdGmSR8+fBhjkkfhRO+lApxE+508+UQsTmPYvtKEKVl9HvWbdSR37twlS5Z8+eWXYXX58uXZA7MiIIHtNPTpAwQSdG8ZjCyvKyZOnMjzF1xETvhST5OaNWuiKy5btox8LDRsEVFZR44cCW2w39x0k+Nkkt0awgeN1NWBPZ0ghKEK5hz4DNPgObYc9pbQkpr16tWjZ3a2119/PaeQB9J+++239MlVdOvWzZWHbrcwmQ0kdGVj6WaynyQNVzNkyPD1118jG5GW5Fx77bWzZs2iW/jM/nb+/Pm8oXFbKXGmI3DG0BLN85lnnjnVW/vwpYE3CWLw3MPM1q1bs0ljt4aFkwp33nknBhjy0RhRZaljd5VW3AX2YNM5c+aEYKidbAuhB8YYdFe4bUtpDsGqVatm7bQkUKfbtm0Led58800uBJoxk0ByWgJj/nHHogKimMpDhw6F7ajHmH/sBtIK86uvvprK1atXZ6psWd2GSpzpCJy9DikxhPIFnaJFi8IQexfROZG65GTOfDxqAnH4jhxBYLKR89xmdEt2jDYT2w/2G0h43nnneap5TtnBUpn+A+23njohTzHPYpHKnz9/jhw5QlZQ5pmLQEiHlGcvLSO8kWizr732mqcybylRUz2ZOhUCUSAgWkYBmpoIgbRFICQtz5i9Zdpio96FQCIhIFom0t3QXITAcQRESz0IQiDhEBAtE+6WaEJCQLTUMyAEEg4B0TLhbokmJARESz0DQiDhEBAtE+6WaEJCQLTUMyAEEg4B0TLhbokmJARESz0DQiDhEBAtE+6WaEJCQLTUMyAEEg4B0TLhbokmJARESz0DQiDhEBAtE+6WaEJCQLTUMyAEEg4B0TLhbokmJARESz0DQiDhEEgs9814msPLmwUJH8f3338/DiOtC2MyCSWAdzk8JhOeJCSQeKyzweeWLl3qRgEhiMjrr79O6A63CaF4XC91OETGBySOJPGS7lbAm7N1h/fII4/gnJLYBxThJZ14BLTFdeVLL71EuIEaNWrgDJIifEbi0BXPlKRxcP7AAw8w+cCZuz0rIQQiQSBGtCTQwKRJkwj1gaN+HPvjFzzk5Ah0g/tWIgXYUghJ3AG3Js7miF2Fq1gC4xC6g3zi8ODcFbfipOEznlQtLXGpjEfmZs2aUYQbSMJmQTxLRfy10ontk2pE6cGdOXGBbA4ukkl89NFHdi3Asyvhse677z68xRKwAM/OMBOPkkQxINAQ9LOtAj+nTJnC1dFkyJAhxOcMLFJaCESIQCxoaUNB1q1bF8nD08yB+DrV/HBMPm7cOEqhH86R8RpOGika6Oz4nHPOIWCBzSd6j03j9DWwT9wrQ2/X4ysCkDSeYKlGE2oS7gqf6DCNeHU4X2bcYcOGEe0HUezKZ3omfhbxhXAPvXjxYpiGqKQV4bHwqk41wm/BQOiND3Vmi6NKvFfi1hmH60uWLEGKEnrI9UMbOD2lhUAYBGJBS2Qg8XZ46JkHXo8RYjzHlm8hZ/bzzz+jr1LUs2dPG875888/R+LBClsfAtiYAvbUTQcG3oNONCG0TseOHW01ImfBwHvvvdf6MkftRIBDJBKPP/44dXBYTgxm6wedU0QiMyHBVCEbcttGGUG6EmmP+JYUQX6k6I033njbbbfhXploBXDe+keH/9SkZ+LnUlOHEIgcgVjQkigARNGxc+LJhjw2TlbwLAnmgWxhZ4h3cxz72+B26ITEC4E8bn1IjnTilMgfhFu1shdJiHrs1mFLCQPdoLEon+wD7VYQvuGUGaqzXbSBIqEc8QJYAtCTIScRPjgQtmiheEwntOs333yDQssnUQZwso6cZA52LDphmUCpRn9+5ZVXICcaO6F7ID9qwqZNm9wpKSEEIkQgFpZY5A865NGjRxEsPOhsyawwDJ4iOiEkxMSChsljTTQ7mEA1AjkmG9nO0xtBCthVQj+bj6wmyCT0JloeRUwGoqKjEr6OeFhEH2BFwJCDgg1FCU3J8gHxIKoVthD+k08+YWNMbEyuBSFpIwvROWITArNlJUQXpSwoNiw0UYwwAilij+e+6DQSBGIhLZkHDzqKH3IG0wsRsk41M6ys+fLlu+iii2AUogYxi+QhAA6fNlAPDZGKqKaEcyTN/hNd0aYD+7QRCiAV8a06depEEZ/IXjaE8JwIreRgH0IsI285kJnQyY1LC51cxdh2y8YYAhM3FiWcaF9EzmKJYaXAiIXZiVJiAREhE10XujJhgnOxvhARyCrMgXNTWggki0AspCVEQuag3bHZC8NJ5gobiTyFdYd3D5hMeO4x9qBt1q5d232lgVqICEJGcWCeQV20aWSde7X0g7kV8WW3eeSz/WNjCW1snDxyeJMBqzmgLrQnto89haLQ1e3KJhD4BI0lXh1vU5CoRPViVn/88Qckv/322y33iK5FHWhJ6Mvly5dTZCNqebrSqRBIFoFY0BKNdO3ate3atWOfhlWTA2mGdAqOV0m8cV4/MGnkFaFa2cjx6pIQ5YHhkDHD8PTDEw5EKy9C3LR7tQzEKuCekkBNxSrDLhSG23zIw/4T5RMpSmxJxCmnHETFY2i3LaRlWeEUPqMGo8fCWyhNaHd4Tig+2rqVsfEQRJ3VhA0qiwLS0i1SQghEjkAsaIncQNXkJQQRi+0BM4MjUlKHOK1Qjp0kF4DthwQ5sNqmsaywA0Ti8TLDc4VYcZCubibMsZZe8m0mqwCkQn0l0jM7WDLZXmKtYbHgdUv//v1tNfjG0nDBBRfY03fffZdvBbAL5Z0N705QYmEsywQmHyxShHwn4Qa3Yyx2rRh+kPZwni8qMBxque1Kn0IgcgRisbfkRR9H8Jx4cRKYCXOwf0IS9+W+LUVUIpdIQ2m+M4C2SXByW4Rmy6YOLvFGFEpgeiUf4cZbCt58sJtF7RwwYACZpBGMCEy+nYPZ6T//+Q/LBBxr1apVw4YN0UIhLWownZQqVcoGdSWNocgaV/nSAm8gEcKsHXZoPlHI3TiznLIu2JdAtgIT4LsKaNHuGxq3oRJCIDwCiRXfEibYd/1hJs1uM9kX9DATOYZ2iiiDewgujKXk2G4Ra/AZkxLarzsQ3dKK/MCYsMg6doxunVMlEL+0cne/p6qmfCEQjEDIQHqJRcvgSStHCPgbgZC0jMXe0t+w6uqEQKojIFqmOqTqUAikFAHRMqUIqr0QSHUERMtUh1QdCoGUIiBaphRBtRcCqY6AaJnqkKpDIZBSBETLlCKo9kIg1REQLVMdUnUoBFKKgGiZUgTVXgikOgKiZapDqg6FQEoREC1TiqDaC4FUR0C0THVI1aEQSCkC/qclv6vkJ2MJ/rtHfjKGN0B+xZLS+6n2vkAgQWmJFw9+FckvFSdPnowHkGCo+Y0lFayHyOBSm0MdfrqJtzt+sckvOfldJb9gPlVl8ufMmcOPs8NUSIsifhGKLyKcHuCQAbcGeK/Ed0lqDYQvbH7JnVq9qZ/YIcCzG/nBLxg5Iq8fXU185PDrfn5DPGvWLHx54M/K0w/+Cp566inq4FDHUxR4SrwD6uCxDp8GcHv8+PGcwuTAOoFpfiTNiIE5aZ2Gk0zJ/vwaUYkfoAYNGuD7K7XGZXUDzNTqTf2kBQI7/zoQ/JeI0tJ194zXVsgJkVDwAhcqXEhaxx+BmcFp3D1369YN5z38bJpfM+PotUOHDjymtiZ+QPCXhSce/HSh6P73v//98ccfSVuXJQgZ3EwjYHEAC2Go7IZXwKGBldLENaAVvTGfNm3aIPSIWUL/eNCjDg717EC4KcHRSfD0yBk7dixDINPw+I6HBFxy4e6ZRYeYC/TAr7dtK2aFN2rSnlmRg3TFQRFO96jDHKwazCfOUHADzwxhJtWYsJ1h37590efRmekf3Z4iULI+U3CwhEdcll0ydcQXgUSkZbLunvv168dTGOhDPRjEbdu24R3LdS+C11ZkJoEJ0GapTOgeHHzhjwdNGOeu8AodEsewCEy8kCDEcMGOIxJIgi+fF198EecGuO2jIQKNR9wNVYIjL3rmsUZPxh0JgyL6cIkAx+iT+vhbwHWlDcfgmSRrAb15vGnaMEQEMsI9iu2BBJwMOSs6xHcZbmlxXIQnWxz2WT8sdLto0SJceLLQAAKzgoT08Nxzz7GcsdLhmgznDFRm+Ye6HFzF6tWrWQhcP0ae2eo0lggkIi3x5RGhu+cwSPHYUWqpy44Rv6/2QGCSj/wcPnw4znh4CnHxzuOLA1j8lZQoUQK5ShAEOMmjDKtxvQdvceqFc1qEDI8+jzufPMd46CIf4uFWC7eU9EMneIilf9zk4ZiLBLKXOTA0ac9hHeq5rkxsKTwhARVZJohQRBq3tLjqoofgWdkm+OBj+UDS4oYPSUumXWXcZQs3RSwr+AejE+JHMHkuhGvHaybI4O6E/n/44QfIzBaXBcV2q884IhALF1tRXF6E7p7D9IxAoBQJgCSBMFCLU/xlIV5IwEC2mjjdss9uzZo1A7vCMR/Pt+vpizo81rj2snISEuKwC/qRCQ/R/dBXka543yLHxnHg+UZ3RfeGIXgGC+l8yLq9xNEeTnHd0a3OyWKByoDDaJz9YYgiXhhsCZ6VbeV6o0UfxhUYKgAXax2L2Qpwj35wKeiOgh7LijNmzBg8aGISw1Uf00DA0oNbR4k4IpCItESMYIPFcxxqoUeYRI4UbqChE9om6iWssO5nLSfpBH7i4h3DLCxCgHi6JZYBTvSsxzoWCGQLFdA2edyZGxxGvLBdtK6oMTuxRXzzzTfREnEkbYOjwE/Mqlib8Nln95+eITiFDMg3eBsYkI8JM22cX3LhcAZOYrjCHE39kLOy/djO2UWzOrD/xJZrnffZfPhPVxMmTOAUTR4FniWGZQsdAWe2zAF8GAjVHZXeNtFnfBFIRI0FSRWhu2cXO6wXHmfQPPSEpiTeAcokjym7JsLa2T0hrZBjOJ6Ek0gnnMqyzSOTp9NakpAkPKaowSio2FSsv3YysdMi2RBcSBjSPNC0wkaCs2aIhAhCwFqjC/nosUOHDkVFhJ+chjwwzMANpCLMxx8fFCWGEiuCXYwwR7FvhEIQnuYhZxXYLXtawi6w8Uatxa+nW4RDauQ84h1MQAkzGJeArg5XAQcpSgUw5yo8Pq/dHpSIMQKJSMsI3T0HIoWeBus8b/wwpWKiRBgSHAGjKxYO3MNafZJ943vvvQev8P6Kkonux+YKsvHehSfVhr6FV0hIyMlzzFiWXdYkE/jJKw3Gha7Ux406o7AWUN+6b2fcMLs1G1QTSYvSS5p1BHsMc7aXZiM10IM9DTkrW+R+MhnSKAhuDlRkVqjrGKLBgbEAyoKA2Ecys51GlUD+W2OY21CJOCLgf4eUSCEEGlqlRx9mTwjlEJg8uLzVREWEP0hLVD4SmF4IdkIdhBUVwt8hKrMuoHXzuKPlIqkQkghPHnTst2xusayiM3s6YUrWUa39HpIdyxLGU9M9Pa1Zua1sgmvEJAsDmZunSKdxRCCkQ0r/0zIuiLOlRKGFnyioTACdGa3YMxPsoth1PJk6PdsQEC1jd8fZJSKdCBOGlhi7UTXSGYiAaHkG3jRN2e8IhKRlIpp8/H4jdH1CIBkERMtkAFKxEIg9AqJl7DHXiEIgGQREy2QAUrEQiD0ComXsMdeIQiAZBETLZABSsRCIPQKiZewx14hCIBkERMtkAFKxEIg9AqJl7DHXiEIgGQREy2QAUrEQiD0ComXsMdeIQiAZBETLZABSsRCIPQKn98Ou2M9PIwoBfyOgr6r7+/7q6vyDgJRY/9xLXYlvEBAtfXMrdSH+QUC09M+91JX4BgHR0je3UhfiHwRES//cS12JbxAQLX1zK3Uh/kFAtPTPvdSV+AYB0dI3t1IX4h8EREv/3EtdiW8QEC19cyt1If5BQLT0z73UlfgGAdHSN7dSF+IfBERL/9xLXYlvEBAtfXMrdSH+QUC09M+91JX4BgHR0je3UhfiHwRES//cS12JbxAQLX1zK3Uh/kHg/wFy0zH5wTN8MgAAAABJRU5ErkJggg==\" width=\"306\" height=\"183\"></p>\n<h3 id=\"4数据面板\">4、数据面板</h3>\n<ol>\n<li>根据日期范围获取指标数据</li>\n<li>通过图表的形式展示指标信息</li>\n<li>查看详情，删除</li>\n<li>各面板的请求设计，支持刷新请求</li>\n</ol>\n<p><img alt=\"数据面板\" src=\"https://blog.palashsh.me/assets/images/image(3)-6eaf69d1ed39ee193e4ee56d6e8d35c4.png\" width=\"987\" height=\"514\">\n<img alt=\"面板详情\" src=\"https://blog.palashsh.me/assets/images/image(4)-893a4623f0ca9f20814d00e858a91767.png\" width=\"1583\" height=\"671\"></p>\n<h3 id=\"5面板导入\">5、面板导入</h3>\n<ol>\n<li>统计目录下选择的面板数量</li>\n<li>导入新面板时，不能破坏已有布局，新面板只能跟在旧面板后</li>\n<li>导入已有面板时，需要进行数据比较，有数据变更需要重新获取最新的数据\n<img alt=\"面板导入\" src=\"https://blog.palashsh.me/assets/images/image(5)-0790488d7db5bf6bfbb57390ae6d112c.png\" width=\"1601\" height=\"694\"></li>\n</ol>\n<h3 id=\"6保存\">6、保存</h3>\n<p>在保存前，所有影响布局相关的操作，都是临时的，包括导入面板。只有在点击保存后，才会把当前数据提交给后端进行保存。</p>\n<h3 id=\"7支持-pdf-和-word-导出\">7、支持 pdf 和 word 导出</h3>\n<p><img alt=\"面板导入\" src=\"https://blog.palashsh.me/assets/images/image(6)-a2c5fdaa6ea14af39ba6aab9c36f2ff9.png\" width=\"1173\" height=\"356\"></p>\n<h1 id=\"巡检报告实现方案\">巡检报告实现方案</h1>\n<h2 id=\"数据结构设计\">数据结构设计</h2>\n<p>先看看使用扁平结构下的\n<img alt=\"%E6%89%81%E5%B9%B3\" src=\"https://blog.palashsh.me/assets/images/%E7%BB%93%E6%9E%84-0e8ea103b13eaefc8f6c62ffc8f97731.png\" width=\"1124\" height=\"1388\">\n在扁平结构下，确定子项只需要找到下一个 row 面板，对于多级目录下也是同理，只是对一级目录需要额外处理。\n这种结构上实现简单，但是需求要求我们限制目录的拖拽，限制目录需要一个比较清晰的面板层级关系，很显然，用树能够很清晰的描述一个数据的层级结构，\n<img alt=\"%E7%BB%93%E6%9E%84.png\" src=\"https://blog.palashsh.me/assets/images/tree-db3209702fd37519dce2af18c3c83929.png\" width=\"1500\" height=\"761\"></p>\n<h2 id=\"组件设计\">组件设计</h2>\n<p>与传统组件编程有所区别。\n在实现上对渲染和数据处理进行了分离，分为两块：</p>\n<ul>\n<li>react 组件：主要负责页面渲染</li>\n<li>class : 负责数据的处理</li>\n</ul>\n<p><img alt=\"%E5%A4%84%E7%90%86.png\" src=\"https://blog.palashsh.me/assets/images/segmentation-3807b28326ce306b52ff3364311044b4.png\" width=\"1347\" height=\"624\">\nDashboardModel</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  id: string | number;\n  panels: PanelModel[]; // 各个面板\n  // ...\n}\n</code></pre>\n<p>PanelModel</p>\n<pre><code class=\"language-jsx\">class PanelModel {\n    key?: string;\n    id!: number;\n    gridPos!: GridPos; // 位置信息\n    title?: string;\n\t\ttype: string;\n    panels: PanelModel[]; // 目录面板需要维护当前目录下的面板信息\n\t\t// ...\n}\n</code></pre>\n<p>每一个 Dashboard 组件对应一个 DashboardModel，每一个 Panel 组件对应一个 PanelModel。\nreact 组建根据类实例中的数据进行渲染。\n实例生产后，不会轻易的销毁，或者改变引用地址，这让依赖实例数据进行渲染的 React 组件无法触发更新渲染。\n需要一个方式，在实例内数据发生改变后，由我们手动触发组件的更新渲染。</p>\n<h3 id=\"组件渲染控制\">组件渲染控制</h3>\n<p>由于我们采用的是 <code>hooks</code> 组件，不像 <code>class</code> 组件有 <code>forceUpdate</code> 方法触发组件的方法。\n而在 <code>react18</code> 中有一个新特性 <code>useSyncExternalStore</code>，可以让我们订阅外部的数据，如果数据发生改变了，会触发组件的渲染。\n实际上 <code>useSyncExternalStore</code> 触发组件渲染的原理就是在内部维护了一个 <code>state</code>，当更改了 <code>state</code> 值，引起了外部组件的渲染。\n基于这个思路简单的实现了一个能够触发组件渲染的 <code>useForceUpdate</code> 方法。</p>\n<pre><code class=\"language-jsx\">export function useForceUpdate() {\n  const [_, setValue] = useState(0);\n  return debounce(() =&gt; setValue((prevState) =&gt; prevState + 1), 0);\n}\n</code></pre>\n<p>虽说实现了 <code>useForceUpdate</code>，但是在实际使用的过程中，还需要在组件销毁时移除事件。\n而 <code>useSyncExternalStore</code> 已经内部已经实现了，直接使用即可。</p>\n<pre><code class=\"language-jsx\">useSyncExternalStore(dashboard?.subscribe ?? (() =&gt; {}), dashboard?.getSnapshot ?? (() =&gt; 0));\n\nuseSyncExternalStore(panel?.subscribe ?? (() =&gt; {}), panel?.getSnapshot ?? (() =&gt; 0));\n</code></pre>\n<p>根据<code>useSyncExternalStore</code>使用，分别添加了 subscribe 和 getSnapshot 方法。</p>\n<pre><code class=\"language-tsx\">class DashboardModel {\n  // PanelModel 一样\n  count = 0;\n\n  forceUpdate() {\n    this.count += 1;\n    eventEmitter.emit(this.key);\n  }\n\n  /**\n   * useSyncExternalStore 的第一个入参，执行 listener 可以触发组件的重渲染\n   * @param listener\n   * @returns\n   */\n  subscribe = (listener: () =&gt; void) =&gt; {\n    eventEmitter.on(this.key, listener);\n    return () =&gt; {\n      eventEmitter.off(this.key, listener);\n    };\n  };\n\n  /**\n   * useSyncExternalStore 的第二个入参，count 在这里改变后触发diff的通过。\n   * @param listener\n   * @returns\n   */\n  getSnapshot = () =&gt; {\n    return this.count;\n  };\n}\n</code></pre>\n<p>当改变数据后，需要触发组件的渲染，只需要执行<code>forceUpdate</code> 即可。</p>\n<h2 id=\"面板拖拽\">面板拖拽</h2>\n<p>市面上比较大众的拖拽插件有以下几个：</p>\n<ul>\n<li>react-beautiful-dnd</li>\n<li>react-dnd</li>\n<li>react-grid-layout</li>\n</ul>\n<p>经过比较后，发现 <code>react-grid-layout</code> 非常适合用来做面板的拖拽功能，<code>react-grid-layout</code> 本身使用简单，基本无上手门槛，最终决定使用 <code>react-grid-layout</code> 详细说明可以查看以下链接：\n<a href=\"https://github.com/react-grid-layout/react-grid-layout\">https://github.com/react-grid-layout/react-grid-layout</a>\n在面板布局改变后触发<code>react-grid-layout</code> 的<code>onLayoutChange</code> 方法，可以拿到布局后的所有面板最新的位置数据。</p>\n<pre><code class=\"language-jsx\">const onLayoutChange = (newLayout: ReactGridLayout.Layout[]) =&gt; {\n    for (const newPos of newLayout) {\n        panelMap[newPos.i!].updateGridPos(newPos);\n    }\n    dashboard!.sortPanelsByGridPos();\n};\n</code></pre>\n<p>panelMap 是一个 map，key 为 Panel.key， value 为面板。是在我们组件渲染时就已经准备好了。</p>\n<pre><code class=\"language-jsx\">const panelMap: Record&lt;PanelModel['key'], PanelModel&gt; = {};\n</code></pre>\n<p>可以通过 panelMap 找到对应的面板，执行面板的 <code>updateGridPos</code> 方法进行更新面板的布局数据。\n到这，我们只是完成了面板本身数据更新，还需要执行仪表盘的 <code>sortPanelsByGridPos</code> 方法，对所有的面板进行排序。</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  sortPanelsByGridPos() {\n    this.panels.sort((panelA, panelB) =&gt; {\n      if (panelA.gridPos.y === panelB.gridPos.y) {\n        return panelA.gridPos.x - panelB.gridPos.x;\n      } else {\n        return panelA.gridPos.y - panelB.gridPos.y;\n      }\n    });\n  }\n  // ...\n}\n</code></pre>\n<h2 id=\"面板拖动范围\">面板拖动范围</h2>\n<p>目前的拖动范围是整个仪表盘，可随意拖动，如下：\n<img alt=\"Untitled-2022-03-01-1710.png\" src=\"https://blog.palashsh.me/assets/images/Untitled-2022-03-01-1710-43e8690ac56dd2f27f542502b9a0c1ac.png\" width=\"1340\" height=\"1644\">\n绿色是仪表盘可拖拽区域，灰色为面板。\n如果需要限制就需要改成如下的结构：\n<img alt=\"Untitled-2022-03-01-1710 1.png\" src=\"https://blog.palashsh.me/assets/images/Untitled-2022-03-01-1710%201-a1c166b6826ad6ea692f48f908b8ca0a.png\" width=\"1340\" height=\"1644\">\n在原本的基础上，以目录为单位区分，绿色为整体的可移动区域，黄色为一级目录块，可在绿色区域拖动，拖动时以整个黄色块进行拖动，紫色为二级目录块，可在当前黄色区域内拖动，不可脱离当前黄色块，灰色的面板只能在当前目录下拖动。\n在原先数据结构基础上进行改造：\n<img alt=\"Untitled 6.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%206-639d70dfc75a868c893c7838d4851c1e.png\" width=\"1500\" height=\"817\"></p>\n<pre><code class=\"language-jsx\">class PanelModel {\n    dashboard?: DashboardModel; // 当前目录下的 dashboard\n\t\t// ...\n}\n</code></pre>\n<h2 id=\"目录\">目录</h2>\n<h3 id=\"目录收缩展开\">目录收缩展开</h3>\n<p>为目录面板维护一个 <code>collapsed</code>属性用来控制面板的隐藏显示</p>\n<pre><code class=\"language-jsx\">class PanelModel {\n    collapsed?: boolean; // type = row\n\t\t// ...\n}\n\n// 组件渲染\n{!collapsed &amp;&amp; &lt;DashBoard dashboard={panel.dashboard} serialNumber={serialNumber} /&gt;}\n</code></pre>\n<p>对目录进行收缩展开时，会改变自身的高度，现在还需要把这个改变的高度同步给上一级的仪表盘。\n上一级需要做的就是类似我们控制目录的处理。如下，控制第一个二级目录收缩：\n<a target=\"_blank\" data-nobrokenlinkcheck=\"true\" href=\"https://blog.palashsh.me/assets/files/Untitled-2022-03-01-1710%202-04fcf3f4e172d80d76bcbcda6dd996b0.png\">Untitled-2022-03-01-1710 2.png</a>\n当面板发生变更时，需要通知上级面板，进行对应的操作。\n<img alt=\"Untitled 1.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%201-fbc66d801e13779fb8574bf9eea15f95.png\" width=\"1500\" height=\"817\">\n增加一个 top 用来获取到父级实例。</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n    top?: null | PanelModel; // 最近的 panel 面板\n\n\t\t/**\n     * 面板高度变更，同步修改其他面板进行对应高度 Y 轴的变更\n     * @param row 变更高度的 row 面板\n     * @param h 变更高度\n     */\n    togglePanelHeight(row: PanelModel, h: number) {\n        const rowIndex = this.getIndexById(row.id);\n\n        for (let panelIndex = rowIndex + 1; panelIndex &lt; this.panels.length; panelIndex++) {\n            this.panels[panelIndex].gridPos.y += h;\n        }\n        this.panels = [...this.panels];\n\n        // 顶级 dashBoard 容器没有 top\n        this.top?.changeHeight(h);\n        this.forceUpdate();\n    }\n\t\t// ...\n}\n\nclass PanelModel {\n    top: DashboardModel; // 最近的 dashboard 面板\n\n    /**\n     * @returns h 展开收起影响的高度\n     */\n    toggleRow() {\n        this.collapsed = !this.collapsed;\n        let h = this.dashboard?.getHeight();\n        h = this.collapsed ? -h : h;\n        this.changeHeight(h);\n    }\n\n    /**\n     *\n     * @param h 变更的高度\n     */\n    changeHeight(h: number) {\n        this.updateGridPos({ ...this.gridPos, h: this.gridPos.h + h }); // 更改自身面板的高度\n        this.top.togglePanelHeight(this, h); // 触发父级变更\n        this.forceUpdate();\n    }\n\t\t// ...\n}\n</code></pre>\n<p>整理流程与冒泡类型，一直到最顶级的 Dashboard。\n<img alt=\"Untitled 2.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%202-2533d4a8915ed1dccfcb75646c1acda7.png\" width=\"2335\" height=\"652\">\n展开收缩同理。</p>\n<h2 id=\"面板的删除\">面板的删除</h2>\n<p>对于面板的删除，我们只需要在对应的 Dashboard 下进行移除，删除后会改变当前 Dashboard 高度，这块的处理与上面的目录收缩一致。</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  /**\n   * @param panel 删除的面板\n   */\n  removePanel(panel: PanelModel) {\n    this.panels = this.filterPanelsByPanels([panel]);\n\n    // 冒泡父容器，减少的高度\n    const h = -panel.gridPos.h;\n    this.top?.changeHeight(h);\n\n    this.forceUpdate();\n  }\n\n  /**\n   * 根据传入的面板进行过滤\n   * @param panels 需要过滤的面板数组\n   * @returns 过滤后的面板\n   */\n  filterPanelsByPanels(panels: PanelModel[]) {\n    return this.panels.filter((panel) =&gt; !panels.includes(panel));\n  }\n  // ...\n}\n</code></pre>\n<h2 id=\"面板的保存\">面板的保存</h2>\n<p>PS：与后端沟通后，当前巡检报告数据结构由前端自主维护，最终给后端一个字符串就好。\n获取到目前的面板数据，用 JSON 进行转换即可。\n面板的信息获取过程，先从根节点出发，遍历至叶子结点，再从叶子结点开始，一层层向上进行返回，也就是回溯的过程。</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  /**\n   * 获取所有面板数据\n   * @returns\n   */\n  getSaveModel() {\n    const panels: PanelData[] = this.panels.map((panel) =&gt; panel.getSaveModel());\n    return panels;\n  }\n  // ...\n}\n\n// 最终保存时所需要的属性，其他的都不需要\nconst persistedProperties: { [str: string]: boolean } = {\n  id: true,\n  title: true,\n  type: true,\n  gridPos: true,\n  collapsed: true,\n  target: true\n};\n\nclass PanelModel {\n  /**\n   * 获取所有面板数据\n   * @returns\n   */\n  getSaveModel() {\n    const model: any = {};\n\n    for (const property in this) {\n      if (persistedProperties[property] &amp;&amp; this.hasOwnProperty(property)) {\n        model[property] = cloneDeep(this[property]);\n      }\n    }\n    model.panels = this.dashboard?.getSaveModel() ?? [];\n\n    return model;\n  }\n  // ...\n}\n</code></pre>\n<h2 id=\"面板\">面板</h2>\n<h3 id=\"面板的导入设计\">面板的导入设计</h3>\n<p><img alt=\"Untitled 3.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%203-9d0107ff0f3784653b65b53b9d9b6612.png\" width=\"1128\" height=\"623\">\n后端返回的数据是一颗有着三级层级的树，我们拿到后，在数据上维护成 <code>moduleMap</code>， <code>dashboardMap</code> 和 <code>panelMap</code> 3 个 Map。</p>\n<pre><code class=\"language-jsx\">import { createContext } from 'react';\n\nexport interface Module { // 一级目录\n    key: string;\n    label: string;\n    dashboards?: string[];\n    sub_module?: Dashboard[];\n}\n\nexport interface Dashboard { // 二级目录\n    key: string;\n    dashboard_key: string;\n    label: string;\n    panels?: number[];\n    selectPanels?: number[];\n    metrics?: Panel[];\n}\n\nexport interface Panel {\n    expr: Expr[]; // 数据源语句信息\n    label: string;\n    panel_id: number;\n}\n\ntype Expr = {\n    expr: string;\n    legendFormat: string;\n};\n\nexport const DashboardContext = createContext({\n    moduleMap: new Map&lt;string, Module&gt;(),\n    dashboardMap: new Map&lt;string, Dashboard&gt;(),\n    panelMap: new Map&lt;number, Panel&gt;(),\n});\n</code></pre>\n<p>我们在渲染模块时，遍历 <code>moduleMap</code> ，并通过 <code>Module</code> 内的<code>dashboards</code>信息找到二级目录。\n在交互上设置一级目录不可选中，当选中二级目录时，通过二级目录 <code>Dashboard</code> 的 <code>panels</code> 找到相关的面板渲染到右侧区域。\n对于这 3 个<code>Map</code>的操作，维护在 <code>useHandleData</code>中，导出：</p>\n<pre><code class=\"language-jsx\">{\n\t\t...map, // moduleMap、dashboardMap、panelMap\n\t\tgetData, // 生成巡检报告的数据结构\n\t\tinit: initData, // 初始化 Map\n}\n</code></pre>\n<h3 id=\"面板选中回填\">面板选中回填</h3>\n<p>在进入面板管理时，需要回填已选中的面板。我们可以通过 <code>getSaveModel</code> 获取到当前巡检报告的信息。把对应的选中信息存放到 <code>selectPanels</code> 中。\n现在我们只需要改变 <code>selectPanels</code> 中的值，就可以做到对应面板的选中。</p>\n<h3 id=\"面板选中重置\">面板选中重置</h3>\n<p>直接遍历 <code>dashboardMap</code>，并把每个<code>selectPanels</code>重置。</p>\n<pre><code class=\"language-jsx\">dashboardMap.forEach((dashboard) =&gt; {\n  dashboard.selectPanels = [];\n});\n</code></pre>\n<h3 id=\"面板插入\">面板插入</h3>\n<p>在我们选中面板后，对选中面板进行插入时，有几种情况：</p>\n<ul>\n<li>巡检报告原本存在的面板，这次也选中，在插入时会比较数据，如果数据发生改变，需要根据最新的数据源信息进行请求，并渲染。</li>\n<li>巡检报告原本存在的面板，这次未选中，在插入时，需要删除掉未选中的面板。</li>\n<li>新选中的面板，在插入时，在对应目录的末尾进行插入。</li>\n</ul>\n<p>添加新面板需要，与目录收缩类似，不同的是：</p>\n<ol>\n<li>目录收缩针对只有一个目录，而插入在针对的是整体。</li>\n<li>目录收缩是直接从子节点开始向上冒泡，而插入是先从根节点开始向下插入，插入完成后在根据最新的目录数据，更新一遍布局。</li>\n</ol>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  update(panels: PanelData[]) {\n    this.updatePanels(panels); // 更新面板\n    this.resetDashboardGridPos(); // 重新布局\n    this.forceUpdate();\n  }\n\n  /**\n   * 以当前与传入的进行对比，以传入的数据为准，并在当前的顺序上进行修改\n   * @param panels\n   */\n  updatePanels(panels: PanelData[]) {\n    const panelMap = new Map();\n    panels.forEach((panel) =&gt; panelMap.set(panel.id, panel));\n\n    this.panels = this.panels.filter((panel) =&gt; {\n      if (panelMap.has(panel.id)) {\n        panel.update(panelMap.get(panel.id));\n        panelMap.delete(panel.id);\n        return true;\n      }\n      return false;\n    });\n\n    panelMap.forEach((panel) =&gt; {\n      this.addPanel(panel);\n    });\n  }\n\n  addPanel(panelData: any) {\n    this.panels = [...this.panels, new PanelModel({ ...panelData, top: this })];\n  }\n\n  resetDashboardGridPos(panels: PanelModel[] = this.panels) {\n    let sumH = 0;\n    panels?.forEach((panel: any | PanelModel) =&gt; {\n      let h = ROW_HEIGHT;\n      if (isRowPanel(panel)) {\n        h += this.resetDashboardGridPos(panel.dashboard.panels);\n      } else {\n        h = panel.getHeight();\n      }\n\n      const gridPos = {\n        ...panel.gridPos,\n        y: sumH,\n        h\n      };\n      panel.updateGridPos({ ...gridPos });\n      sumH += h;\n    });\n\n    return sumH;\n  }\n}\n\nclass PanelModel {\n  /**\n   * 更新\n   * @param panel\n   */\n  update(panel: PanelData) {\n    // 数据源语句发生变化需要重新获取数据\n    if (this.target !== panel.target) {\n      this.needRequest = true;\n    }\n\n    this.restoreModel(panel);\n\n    if (this.dashboard) {\n      this.dashboard.updatePanels(panel.panels ?? []);\n    }\n\n    this.needRequest &amp;&amp; this.forceUpdate();\n  }\n}\n</code></pre>\n<h3 id=\"面板请求\">面板请求</h3>\n<p><code>needRequest</code> 控制面板是否需要进行请求，如果为 <code>true</code> 在面板下一次进行渲染时，会进行请求。\n请求的处理也放在了 PanelModel 中。(是否单独维护请求的逻辑？)</p>\n<pre><code class=\"language-jsx\">import { Params, params as fetchParams } from '../../components/useParams';\n\nclass PanelModel {\n\t\ttarget: string; // 数据源信息\n\n\t\tgetParams() {\n        return {\n            targets: this.target,\n            ...fetchParams,\n        } as Params;\n    }\n\n    request = () =&gt; {\n        if (!this.needRequest) return;\n        this.fetchData(this.getParams());\n    };\n\n    fetchData = async (params: Params) =&gt; {\n        const data = await this.fetch(params);\n        this.data = data;\n        this.needRequest = false;\n        this.forceUpdate();\n    };\n\n\t\tfetch = async (params: Params) =&gt; { /* ... */ }\n}\n</code></pre>\n<p>我们数据渲染组件一般层级较深，而请求时会需要时间区间等外部参数。对于这部分参数采用全局变量的方式，用 <code>useParams</code> 进行维护。上层组件使用 change 修改参数，数据渲染组件根据抛出的 <code>params</code> 进行请求。</p>\n<pre><code class=\"language-jsx\">export let params: Params = {\n    decimal: 1,\n    unit: null,\n};\n\nfunction useParams() {\n    const change = (next: (() =&gt; Params) | Params) =&gt; {\n        if (typeof next === 'function') params = next();\n        params = { ...params, ...next } as Params;\n    };\n\n    return { params, change };\n}\n\nexport default useParams;\n</code></pre>\n<h3 id=\"面板刷新\">面板刷新</h3>\n<p><img alt=\"Untitled 4.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%204-639d70dfc75a868c893c7838d4851c1e.png\" width=\"1500\" height=\"817\"></p>\n<p>从根节点向下查找，找到叶子节点，在触发对应的请求。</p>\n<pre><code class=\"language-jsx\">class DashboardModel {\n  /**\n   * 刷新子面板\n   */\n  reloadPanels() {\n    this.panels.forEach((panel) =&gt; {\n      panel.reload();\n    });\n  }\n}\n\nclass PanelModel {\n  /**\n   * 刷新\n   */\n  reload() {\n    if (isRowPanel(this)) {\n      this.dashboard.reloadPanels();\n    } else {\n      this.reRequest();\n    }\n  }\n\n  reRequest() {\n    this.needRequest = true;\n    this.request();\n  }\n}\n</code></pre>\n<h2 id=\"右侧目录渲染\">右侧目录渲染</h2>\n<h3 id=\"锚点序号\">锚点/序号</h3>\n<p>锚点采用 Anchor + id 选中组件。\n序号根据每次渲染进行生成。</p>\n<h3 id=\"采用发布订阅管理渲染\">采用发布订阅管理渲染</h3>\n<p>每当仪表盘改变布局的动作时，右侧目录就需要进行同步更新。而任意一个面板都有可能需要触发右侧目录的更新。\n如果我们采用实例内维护对应组件的渲染事件，有几个问题：</p>\n<ol>\n<li>需要进行区分，比如刷新面板时，不需要触发右侧目录的渲染。</li>\n<li>每个面板如何订阅右侧目录的渲染事件？</li>\n</ol>\n<p>最终采用了发布订阅者模式，对事件进行管理。</p>\n<pre><code class=\"language-jsx\">class EventEmitter {\n    list: Record&lt;string, any[]&gt; = {};\n\n\t\t/**\n     * 订阅\n     * @param event 订阅事件\n     * @param fn 订阅事件回调\n     * @returns\n     */\n    on(event: string, fn: () =&gt; void) {}\n\n\t\t/**\n     * 取消订阅\n     * @param event 订阅事件\n     * @param fn 订阅事件回调\n     * @returns\n     */\n    off(event: string, fn: () =&gt; void) {}\n\n\t\t/**\n     * 发布\n     * @param event 订阅事件\n     * @param arg 额外参数\n     * @returns\n     */\n    emit(event: string, ...arg: any[]) {\n}\n</code></pre>\n<pre><code class=\"language-jsx\">eventEmitter.emit(this.key); // 触发面板的订阅事件\n\neventEmitter.emit(GLOBAL); // 触发顶级订阅事件，就包括右侧目录的更新\n</code></pre>\n<h2 id=\"面板详情展示\">面板详情展示</h2>\n<p><img alt=\"Untitled 5.png\" src=\"https://blog.palashsh.me/assets/images/Untitled%205-97f3971c7e751aec1dd0ac6abbe8a4a5.png\" width=\"1309\" height=\"786\"></p>\n<p>对面板进行查看时，可修改时间等，这些操作会影响到实例中的数据，需要对原数据与详情中的数据进行区分。\n通过对原面板数据的重新生成一个 <code>PanelModel</code> 实例，对这个实例进行任意操作，都不会影响到原数据。</p>\n<pre><code class=\"language-jsx\">const model = panel.getSaveModel();\nconst newPanel = new PanelModel({ ...model, top: panel.top }); // 创建一个新的实例\nsetEditPanel(newPanel); // 设置为详情\n</code></pre>\n<p>在<code>dom</code>上，详情页面是采用绝对定位，覆盖着巡检报告。</p>\n<h2 id=\"pdfword-导出\">pdf/word 导出</h2>\n<p>pdf 导出由 html2Canvas + jsPDF 实现。需要注意的是，当图片过长 pdf 会对图片进行切分，有可能出现切分的时内容区域。\n需要手动计算面板的高度，是否超出当前文档，如果超出需要我们提前进行分割，添加到下一页中。\n尽可能把目录面板和数据面板一块切分。</p>\n<p>word 导出由 html-docx-js 实现， 需要保留目录的结构，并可以在面板下添加总结，这就需要我们分别对每一个面板进行图片的转换。\n实现的思路是根据 panels 遍历，找到目录面板就是用 <code>h1、h2</code> 标签插入，如果是数据面板，在数据面板中维护一个 <code>ref</code> 的属性，能让我们拿到当前面板的 <code>dom</code> 信息，根据这个进行图片转换，并为 base64 的格式(word 只支持 base64 的图片插入)。</p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>目前实现的巡检报告只是初版并不是最终版，后续迭代中还要增加总结说明等功能，\n采用目前方式实现后，后续迭代上涉及<code>ui</code>变更的只需要更改对应的 <code>ui</code> 组件，比如增加饼图，表格等。数据交互层面上的变更只需要进入 <code>DashboardModel</code> 和 <code>PanelModel</code>中进行修改。甚至于根据情况在抽离专门的类进行处理。</p>",
            "url": "https://blog.palashsh.me/Inspection Report",
            "title": "实现一个巡检报告",
            "summary": "巡检报告是指对某一个系统或设备进行全面检查，并把检查结果及建议整理成报告的过程。巡检报告通常用于评估系统或设备的运行状况与性能，以发现问题、优化系统、提高效率、降低故障率等方面提供参考。",
            "date_modified": "2023-05-11T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "react",
                "design"
            ]
        },
        {
            "id": "https://blog.palashsh.me/IntersectionObserver",
            "content_html": "<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\">Intersection Observer API - Web API 接口参考 | MDN</a></p>\n<h2 id=\"实现一个组件可视化懒加载\">实现一个组件可视化懒加载</h2>\n<pre><code>import React, { useRef, useState } from 'react';\nimport { useEffectOnce } from 'react-use';\nimport { useUniqueId } from '*'; // 唯一值获取，自定义\n\nexport interface Props {\n  children: React.ReactNode | (({ isInView }: { isInView: boolean }) =&gt; React.ReactNode);\n  onLoad?: () =&gt; void;\n}\n\nexport function LazyLoader({ children, onLoad }: Props) {\n  const id = useUniqueId();\n  const [loaded, setLoaded] = useState(false);\n  const wrapperRef = useRef&lt;HTMLDivElement&gt;(null);\n\n  useEffectOnce(() =&gt; {\n\t\t// 注册进入可视区域的触发事件\n    LazyLoader.addCallback(id, (entry) =&gt; {\n      if (!loaded &amp;&amp; entry.isIntersecting) {\n        setLoaded(true);\n        onLoad?.(); // 执行初始化相关的交互\n      }\n    });\n\n    const wrapperEl = wrapperRef.current;\n\n    if (wrapperEl) {\n      LazyLoader.observer.observe(wrapperEl); // 开始监听\n    }\n\n    return () =&gt; {\n      delete LazyLoader.callbacks[id];\n      wrapperEl &amp;&amp; LazyLoader.observer.unobserve(wrapperEl);\n      if (Object.keys(LazyLoader.callbacks).length === 0) {\n        LazyLoader.observer.disconnect();\n      }\n    };\n  });\n\n  return (\n    &lt;div id={id} ref={wrapperRef} &gt;\n      {loaded &amp;&amp; children}\n    &lt;/div&gt;\n  );\n}\n\nLazyLoader.callbacks = {} as Record&lt;string, (e: IntersectionObserverEntry) =&gt; void&gt;;\nLazyLoader.addCallback = (id: string, c: (e: IntersectionObserverEntry) =&gt; void) =&gt; (LazyLoader.callbacks[id] = c);\nLazyLoader.observer = new IntersectionObserver(\n  (entries: IntersectionObserverEntry) =&gt; {\n    for (const entry of entries) {\n      LazyLoader.callbacks[entry.target.id](entry);\n    }\n  },\n  { rootMargin: '100px' }\n);\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-jsx\">&lt;LazyLoader onLoad={this.onPanelLoad}&gt;\n  &lt;Panel /&gt;\n&lt;/LazyLoader&gt;\n</code></pre>",
            "url": "https://blog.palashsh.me/IntersectionObserver",
            "title": "Intersection Observer API",
            "summary": "Intersection Observer API - Web API 接口参考 | MDN",
            "date_modified": "2023-04-12T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "performance"
            ]
        },
        {
            "id": "https://blog.palashsh.me/softwareDevelopmentSex",
            "content_html": "<p>身为程序员对与编码中的可拓展性应该要非常了解的，并不断实践中，具体是指的是在代码设计的过程中，需要为将来可能出现的新功能预先设定好拓展点，不会出现新加了一个功能，导致更改了大量原始代码的情况。</p>\n<p>而在软件中的拓展性，却不当当指的是新功能的拓展，还有在运营环境中稳定。</p>\n<p>在以下场景中，商店中悄然上架了一个贵公司的软件，一直不温不火的，突然有一天火了，从原先的 1w+的人流量，暴增至 10+ 以上的人流量，这时候服务器撑不住了，如果你是贵公司的老板，你将面临以下几个选择：</p>\n<ul>\n<li>选择一：马上召集公司的程序员加班优化软件。</li>\n<li>选择二：马上扩增服务器。</li>\n</ul>\n<p>其实就一种选择，扩增服务器，为什么呢？</p>\n<p>让程序员进行修改，第一个是时间问题，而一个软件的爆火是有实效性的，如果不能在短时间内跟上，随着而来的就可以能是用户的负反馈，继而恢复至原本的 1w+，甚至更少。，第二个是成本问题，就比较现实了，是程序员便宜还是服务器便宜，相信大家心中都有答案。</p>\n<p>所以在软件设计之初，就需要考虑到后续服务的拓展以及稳定上。</p>\n<p>还有一些硬件升级后，能否在最新的硬件上正常执行，也是拓展性的一种。</p>",
            "url": "https://blog.palashsh.me/softwareDevelopmentSex",
            "title": "软件的拓展性",
            "summary": "身为程序员对与编码中的可拓展性应该要非常了解的，并不断实践中，具体是指的是在代码设计的过程中，需要为将来可能出现的新功能预先设定好拓展点，不会出现新加了一个功能，导致更改了大量原始代码的情况。",
            "date_modified": "2023-04-12T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "design"
            ]
        },
        {
            "id": "https://blog.palashsh.me/Authority design",
            "content_html": "<blockquote>\n<p><em>访问控制</em>（Access control）是指对访问者向受保护资源进行访问操作的控制管理。该控制管理保证被授权者可访问受保护资源，未被授权者不能访问受保护资源。</p>\n</blockquote>\n<p>现实生活中的访问控制可以由付费或者认证达成。例如：进电影院看电影，需要够买电影票，否则检票员就不让你进去。</p>\n<p>访问控制有很多模型，比如：</p>\n<ul>\n<li>自主访问控制模型 (Discretionary Access Control)</li>\n<li>强制访问控制模型 (MAC: Mandatory Access Control)</li>\n<li>角色访问控制模型 (RBAC: Role-based Access Control)</li>\n<li>属性访问控制模型 (ABAC: Attribute-Based Access Control)</li>\n</ul>\n<h2 id=\"dac\">DAC</h2>\n<p>自主访问控制(DAC: Discretionary Access Control)，系统会识别用户，然后根据访问对象的权限控制列表(ACL: Access Control List)或者权限控制矩阵(ACL: Access Control Matrix)的信息来决定用户是否能对其进行哪些操作，例如读取或修改。而拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为“自主(Discretionary)”控制。</p>\n<p>自主访问控制模型是一种相对比较宽松但是却很有效的保护资源不被非法访问和使用的手段。说它宽松，是因为他是自主控制的，在保护资源的时候是以个人意志为转移的；说它有效，是因为可以明确的显式的指出主体在访问或使用某个客体时究竟是以何种权限来实施的，任何超越规定权限的访问行为都会被访问控制列表判定后而被阻止。</p>\n<p>比较典型的场景是在 Linux 的文件系统中：\n系统中的每个文件（一些特殊文件可能没有，如块设备文件等）都有所有者。文件的所有者是创建这个文件的计算机的使用者（或事件，或另一个文件）。那么此文件的自主访问控制权限由它的创建者来决定如何设置和分配。文件的所有者拥有访问权限，并且可以将访问权限分配给自己及其他用户</p>\n<h2 id=\"mac\">MAC</h2>\n<p>强制访问控制(MAC: Mandatory Access Control)，用于将系统中的信息分密级和类进行管理，以保证每个用户只能访问到那些被标 &nbsp; 制访问控制下，用户（或其他主体）与文件（或其他客体）都被标记了固定的安全属性（如安全级、访问权限等），在每次访问发生时，系统检测安全属性以便确定一个用户是否有权访问该文件。</p>\n<p>MAC最早主要用于军方的应用中，通常与DAC结合使用，两种访问控制机制的过滤结果将累积，以此来达到更佳的访问控制效果。也就是说，一个主体只有通过了DAC限制检查与MAC限制检查的双重过滤装置之后，才能真正访问某个客体。一方面，用户可以利用DAC来防范其它用户对那些所有权归属于自己的客体的攻击；另一方面，由于用户不能直接改变MAC属性，所以MAC提供了一个不可逾越的、更强的安全保护层以防止其它用户偶然或故意地滥用DAC。</p>\n<h2 id=\"rbac\">RBAC</h2>\n<p>角色访问控制 (RBAC: Role-based Access Control)，各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。 每一种角色对应一组相应的权限。 一旦用户被分配了适当的角色后，该用户就拥有此角色的所有操作权限目前来说基于角色的访问控制模型是应用较广的一个，特别是 2B 方向 SAAS 领域，应用尤其常见，角色访问也就是我们今天要介绍的重点。</p>\n<p>RBAC虽然简化了权限的管理，但是对于复杂场景的角色管理，它依然不够灵活。比如主体和客体之间的权限复杂多变，可能就需要维护大量的角色及其授权关系；新增客体也需要对所有相关角色进行处理。基于属性的角色访问控制就是为了解决这个问题。</p>\n<h2 id=\"abac\">ABAC</h2>\n<p>属性访问控制（Attributes-based Access Control）是一种非常灵活的访问控制模型。属性包括请求主体的属性、请求客体的属性、请求上下文的属性、操作的属性等。如身为班主任（主体的属性）的老张在上课（上下文的属性）时可以踢（操作属性）身为普通学生（客体的属性）的小明一脚。可以看到，只要对属性进行精确定义及划分，ABAC可以实现非常复杂的权限控制。</p>\n<p>比如：大二（年级）计科（专业）二班（班级）的班干（职位）可以在学校内网（环境）上传（操作）班级的照片。</p>\n<p>但是由于ABAC比较复杂，对于目前的 SAAS 领域，就显得有点大材小用了，所以在SAAS 领域很少见到有使用ABAC的平台，目前使用ABAC比较多的就是一些云服务。</p>\n<h2 id=\"数栈中的-rbac\">数栈中的 RBAC</h2>\n<p>我们产品中采用的是 RBAC 的权限方案，所以我们目前只对 RBAC 进行分析。</p>\n<p>RBAC 是角色访问控制，那么首先我们需要知道的是用户的角色，在这个方面，我们项目中存在了用户管理以及角色管理两个模块。</p>\n<h3 id=\"用户管理\">用户管理</h3>\n<p>在uic的用户管理中提供用户账户的创建、编辑和删除等功能。\n<img alt=\"4734A6B8-3987-4417-B073-DD1F6486FCDB.png\" src=\"https://blog.palashsh.me/assets/images/4734A6B8-3987-4417-B073-DD1F6486FCDB-1e55c4f5168f3aa3d74e1189d5bf89ce.png\" width=\"1500\" height=\"656\"></p>\n<p>在数栈的产品中，存在租户，对于每个租户下也存在着一个用户管理，对租户内的用户进行管理。能够设置当前用户的角色，这些角色包括租户所有者、项目所有者和项目管理者等。\n<img alt=\"E467D569-D438-4828-962C-7B31D298ACF9.png\" src=\"https://blog.palashsh.me/assets/images/E467D569-D438-4828-962C-7B31D298ACF9-3a71e5f7e35b138d5f59a2cb32c155b1.png\" width=\"1500\" height=\"565\"></p>\n<h3 id=\"角色管理\">角色管理</h3>\n<p>在角色管理中可以看到角色的定义，以及它所拥有的访问权限。\n<img alt=\"CE67BF26-F52C-4E9C-9C72-0816827997BF.png\" src=\"https://blog.palashsh.me/assets/images/CE67BF26-F52C-4E9C-9C72-0816827997BF-f7f3199116301e0f25b7e231c8b2b208.png\" width=\"1500\" height=\"619\"></p>\n<p>我们通过在用户管理和角色管理中的用户定义，可以得到当前用户完整的产品访问权限，当用户进入某个功能时，我们就可以通过当前的准入权限以及用户的访问权限，进行比较，进而得出是否准入的结论。</p>\n<p>对于我们前端开发者而言，我们需要的其实就是</p>\n<ol>\n<li>得到用户的一个角色权限</li>\n<li>使用得到的权限进行比较，对结果进行不同的处理</li>\n</ol>\n<p>那我们来看看ant design pro 的权限方案是如何处理的。</p>\n<h2 id=\"ant-design-pro-中的权限方案\">ant design pro 中的权限方案</h2>\n<p>业界比较通用的_ant design pro_中的权限方案是如何设计的呢？</p>\n<h3 id=\"获取用户角色权限\">获取用户角色权限</h3>\n<p>一开始在进入页面的同时，会进行登陆校验。如果未登录会跳转到登录页面，进行登陆操作，登陆成功后，会把当前用户的角色数据通过<code>setAuthority</code>方法存进 <code>localStorage</code> 中，方便我们重新进入页面时获取。\n而对于已经登录校验通过的，会直接进入项目中，会进行渲染页面基础布局 <code>BasicLayout</code> 组件，在 <code>BasicLayout</code> 组件中我们使用到了<code>Authorized</code>组件，在挂载<code>Authorized</code>的时候，触发<code>renderAuthorize</code>给<code>CURRENT</code>进行赋值。后续的权限检查都会使用<code>CURRENT</code>，比较关键。</p>\n<p><img alt=\"Untitled Diagram (1).jpg\" src=\"https://blog.palashsh.me/assets/images/Untitled%20Diagram%20(1)-4164f40e8e85417f73cc9175ad9e9584.jpg\" width=\"813\" height=\"314\"></p>\n<p><code>renderAuthorize</code>方法是一个柯里化函数，在内部使用<code>getAuthority</code>获取到角色数据时对 <code>CURRENT</code>进行赋值。</p>\n<pre><code class=\"language-javascript\">let CURRENT: string | string[] = 'NULL';\n\ntype CurrentAuthorityType = string | string[] | (() =&gt; typeof CURRENT);\n/**\n * use  authority or getAuthority\n * @param {string|()=&gt;String} currentAuthority\n */\nconst renderAuthorize = (Authorized: any) =&gt; (currentAuthority: CurrentAuthorityType) =&gt; {\n  if (currentAuthority) {\n    if (typeof currentAuthority === 'function') {\n      CURRENT = currentAuthority();\n    }\n    if (\n      Object.prototype.toString.call(currentAuthority) === '[object String]' ||\n      Array.isArray(currentAuthority)\n    ) {\n      CURRENT = currentAuthority as string[];\n    }\n  } else {\n    CURRENT = 'NULL';\n  }\n  return Authorized;\n};\n\nexport { CURRENT };\nexport default (Authorized: any) =&gt; renderAuthorize(Authorized);\n</code></pre>\n<p>到这，项目的权限获取以及更新就完成了。接下来就是权限的校验了</p>\n<h3 id=\"校验权限\">校验权限</h3>\n<p>对于权限校验，需要以下环境参数：</p>\n<ol>\n<li>authority：当前访问权限也就是准入权限</li>\n<li>currentAuthority：当前用户的角色，也就是<code>CURRENT</code></li>\n<li>target：校验成功展示的组件</li>\n<li>Exception：校验失败展示的组件</li>\n</ol>\n<p>对于需要进行权限校验的组件，使用<code>Authorized</code>组件进行组合，在<code>Authorized</code>组件内部，实现了<code>checkPermissions</code>方法，用来校验当前用户角色，是否有权限的进行访问。如果有权限，则直接展示当前的组件，如果没有则展示无权限等消息。</p>\n<p><img alt=\"Untitled Diagram (3).jpg\" src=\"https://blog.palashsh.me/assets/images/Untitled%20Diagram%20(3)-7148a94f1fa6fad4833c8e1235bc0eaf.jpg\" width=\"693\" height=\"584\"></p>\n<p><code>Authorized</code>组件的实现，</p>\n<pre><code class=\"language-javascript\">type IAuthorizedType = React.FunctionComponent&lt;AuthorizedProps&gt; &amp; {\n  Secured: typeof Secured;\n  check: typeof check;\n  AuthorizedRoute: typeof AuthorizedRoute;\n};\n\nconst Authorized: React.FunctionComponent&lt;AuthorizedProps&gt; = ({\n  children,\n  authority,\n  noMatch = (\n    &lt;Result\n      status=\"403\"\n      title=\"403\"\n      subTitle=\"Sorry, you are not authorized to access this page.\"\n    /&gt;\n  ),\n}) =&gt; {\n  const childrenRender: React.ReactNode = typeof children === 'undefined' ? null : children;\n  const dom = check(authority, childrenRender, noMatch);\n  return &lt;&gt;{dom}&lt;/&gt;;\n};\n\nfunction check&lt;T, K&gt;(authority: IAuthorityType, target: T, Exception: K): T | K | React.ReactNode {\n  return checkPermissions&lt;T, K&gt;(authority, CURRENT, target, Exception);\n}\n</code></pre>\n<pre><code class=\"language-javascript\">/**\n * 通用权限检查方法\n * Common check permissions method\n * @param { 权限判定 | Permission judgment } authority\n * @param { 你的权限 | Your permission description } currentAuthority\n * @param { 通过的组件 | Passing components } target\n * @param { 未通过的组件 | no pass components } Exception\n */\nconst checkPermissions = &lt;T, K&gt;(\n  authority: IAuthorityType,\n  currentAuthority: string | string[],\n  target: T,\n  Exception: K,\n): T | K | React.ReactNode =&gt; {\n  // 没有判定权限.默认查看所有\n  // Retirement authority, return target;\n  if (!authority) {\n    return target;\n  }\n  // 数组处理\n  if (Array.isArray(authority)) {\n    if (Array.isArray(currentAuthority)) {\n      if (currentAuthority.some((item) =&gt; authority.includes(item))) {\n        return target;\n      }\n    } else if (authority.includes(currentAuthority)) {\n      return target;\n    }\n    return Exception;\n  }\n  // string 处理\n  if (typeof authority === 'string') {\n    if (Array.isArray(currentAuthority)) {\n      if (currentAuthority.some((item) =&gt; authority === item)) {\n        return target;\n      }\n    } else if (authority === currentAuthority) {\n      return target;\n    }\n    return Exception;\n  }\n  // Promise 处理\n  if (authority instanceof Promise) {\n    return &lt;PromiseRender&lt;T, K&gt; ok={target} error={Exception} promise={authority} /&gt;;\n  }\n  // Function 处理\n  if (typeof authority === 'function') {\n    const bool = authority(currentAuthority);\n    // 函数执行后返回值是 Promise\n    if (bool instanceof Promise) {\n      return &lt;PromiseRender&lt;T, K&gt; ok={target} error={Exception} promise={bool} /&gt;;\n    }\n    if (bool) {\n      return target;\n    }\n    return Exception;\n  }\n  throw new Error('unsupported parameters');\n};\n</code></pre>\n<h3 id=\"使用authorized组件\">使用Authorized组件</h3>\n<p>在页面上使用则非常的方便，对需要进行权限管控的组件，使用 <code>Authorized</code>组件进行组合即可。</p>\n<pre><code class=\"language-javascript\">function NoMatch = () =&gt; {\n\treturn &lt;div&gt;404&lt;/div&gt;\n}\n\n&lt;Authorized authority={'admin'} noMatch={NoMatch}&gt;\n  {children}\n&lt;/Authorized&gt;\n</code></pre>\n<p>我们还可以利用路由进行组件的匹配，这里是利用了在 v4 中，无论 &nbsp;组件在哪里书写，只有匹配，次组件就会在哪里渲染。</p>\n<pre><code class=\"language-javascript\">&lt;Authorized\n    authority={authority}\n    noMatch={&lt;Route {...rest} render={() =&gt; &lt;Redirect to={{ pathname: redirectPath }} /&gt;} /&gt;}\n  &gt;\n    &lt;Route\n      {...rest}\n      render={(props: any) =&gt; (Component ? &lt;Component {...props} /&gt; : render(props))}\n    /&gt;\n&lt;/Authorized&gt;\n</code></pre>\n<h2 id=\"我们的权限方案\">我们的权限方案</h2>\n<p>我们目前的权限有两套方案，一是离线质量等产品使用的旧权限方案，二是资产标签使用的新权限方案。</p>\n<h3 id=\"旧权限方案\">旧权限方案</h3>\n<p>在旧方案中，采用通过接口获取数据的方式，但是所获取的数据只到菜单这一级别。将获取到数据后存入缓存中，便于我们的业务包和子产品使用。在业务包中监听页面地址的改变，判断是否有进入当前页面的权限，根据结果来进行相应的处理，实际就是做了个路由守卫的功能。而在子产品中，则是根据数据来判断是否显示当前的菜单入口。这两者结合，形成了我们旧方案。</p>\n<p>随着数栈的成长，旧方案慢慢的也暴露出了许多的问题。</p>\n<ul>\n<li>对权限控制的范围太小，我们只控制到了菜单这一级别，而对于特殊页面和某些场景下需要对功能的控制（如：编辑，新增、删除等），目前只有后端接口进行限制，页面上并没有进行限制，如果需要实现这个功能，就需要添加额外的接口和处理逻辑，</li>\n<li>我们把权限的处理分成两部分，业务包和子产品中，但是两者间的耦合度是非常高的，往往改动了一个地方，另一个也需要跟着更改。</li>\n<li>我们在业务包中，控制各个产品的页面准入逻辑，每当需要增加一个菜单，就需要增加一条对应的菜单处理逻辑，增加一个产品，就需要增加这个产品对应的所有菜单逻辑，目前数栈的子产品已经超过了 10+ ，可以想象这部分处理逻辑是有多么的臃肿。</li>\n</ul>\n<p>实际的问题不止以上列的三点，但是这三点就足够我们进行新的权限方案的探索。</p>\n<h3 id=\"新权限方案\">新权限方案</h3>\n<p>在新方案中，业务包只保留权限的公共方法，把页面权限判断的逻辑进行的下放，子产品自己维护自己的权限判断逻辑，修改一条权限的逻辑也非常的容易，\n<img alt=\"image.png\" src=\"https://blog.palashsh.me/assets/images/image-90aadf8b6e5c85510e1b249d96f4db94.png\" width=\"620\" height=\"975\">\n相比起 ant design pro 中通过角色进行判断，新方案中我们把角色权限的判断逻辑移交给了后端，后端经过了相应的处理后，返回对应的<code>code</code>码集合。</p>\n<p>我们为每个需要设置准入权限的模块，定义一个<code>code</code>码，去比较后端返回的集合中，是否能够找到相同的<code>code</code>，如果能找到说明就有访问当前模块的权限，反之则没有。</p>\n<p>经过这样处理后，我们只需要关心是否能够进入。</p>\n<p>在获取到权限点的时候，还会根据这个权限点，去缓存有权限访问的路由列表，当路由改变时，就可以去有权的路由列表里进行查找，如果没有找到就进行重定向之类的操作，也就是路由守卫的功能。</p>\n<h3 id=\"总结\">总结</h3>\n<p>经过上面的介绍，我们对权限方案已经有所了解，主要分为两个阶段：</p>\n<ol>\n<li>获取权限阶段：在获取权限阶段，往往是用户登入或进入项目时，第一时间根据用户信息获取相对应的权限</li>\n<li>校验权限阶段：通过用户的权限，与当前模块的准入权限进行比对，在根据结果进行操作</li>\n</ol>\n<p>知道了这些之后，就可以结合自身的场景，制定出相应的权限方案。</p>",
            "url": "https://blog.palashsh.me/Authority design",
            "title": "关于ant design pro的权限方案设计",
            "summary": "访问控制（Access control）是指对访问者向受保护资源进行访问操作的控制管理。该控制管理保证被授权者可访问受保护资源，未被授权者不能访问受保护资源。",
            "date_modified": "2021-12-21T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "react",
                "design"
            ]
        },
        {
            "id": "https://blog.palashsh.me/Containment_",
            "content_html": "<p>在开始介绍今天的主角 <em>CSS Containment</em> 之前，我们需要了解一些前置知识回流和重绘，方便我们理解以及应用的场景。</p>\n<h2 id=\"简单回忆下回流和重绘\">简单回忆下回流和重绘</h2>\n<ul>\n<li>回流（Reflow）：当浏览器必须重新处理和绘制部分或全部页面时，回流就会发生，例如元素的规模尺寸，布局，隐藏等改变而需要重新构建。</li>\n<li>重绘（Repaint）：当改变元素的部分属性而不影响布局时，重绘就会发生。例如改变元素的背景颜色、字体颜色等。</li>\n</ul>\n<h2 id=\"回流会造成什么\">回流会造成什么？</h2>\n<blockquote>\n<p>Reflows are very expensive in terms of performance, and is one of the main causes of slow DOM scripts, In many cases, they are equivalent to laying out the entire page again.</p>\n</blockquote>\n<p>通过翻译，我们可以知道，回流在性能方面消耗非常大，是很多 DOM 加载慢的原因之一。在许多情况下，它们相当于再次渲染整个页面。</p>\n<p>接下来，来看看有哪些行为会触发回流/重绘。</p>\n<h3 id=\"触发回流重绘\">触发回流/重绘</h3>\n<ul>\n<li>添加，删除，更新 DOM 节点时会发生回流</li>\n<li>设置元素的属性为<code>display:none</code> 时发生回流</li>\n<li>设置元素的属性<code>visibility: hidden</code> 时发生重绘</li>\n<li>DOM 节点上存在动画属性也将触发回流</li>\n<li>调整窗口的大小将触发回流</li>\n<li><code>font-style</code> 更改字体风格会改变元素的几何形状。 这意味着它可能会影响页面上其他元素的位置或大小,触发回流</li>\n<li>添加或删除样式文件将导致回流/重绘</li>\n<li>通过 JavaScript 获取元素的大小等，由于需要确保获取到的值为最新的，浏览器都会先执行一次回流来保证值的正确。例如 <em>offsetXXX</em>、<em>clientXXX</em> 和 <em>scrollXXX</em> 等</li>\n</ul>\n<h3 id=\"重绘回流优化方案\">重绘回流优化方案</h3>\n<p>知道了触发回流/重绘的原因，那么就能根据这些原因，制定相应的优化方案，如下。</p>\n<ul>\n<li>避免使用触发重绘回流的 CSS 属性。</li>\n<li>尽量减少 JS 操作修改 DOM 的 CSS 次数。</li>\n<li>将频繁重绘回流的 DOM 元素单独作为一个独立图层，那么这个 DOM 元素的重绘和回流影响只会在这个图层中。</li>\n</ul>\n<p>经过了优化后，回流和重绘的次数已经减少，但是不可避免的，由于各种原因，还是会产生回流和重绘。</p>\n<p>试想一下，有一个比较复杂的页面，当用户移动鼠标到一个元素上，触发这个元素<code>hover</code>，这个<code>hover</code>的效果是使这个元素宽高发生改变（<code>width</code>、<code>height</code>），当元素的宽高发生改变时，浏览器需要考虑到所有元素，是否发生了相应的更改，所以浏览器需要对整个页面进行重新布局，而实际上改变的可能只有页面的一小部分，页面大部分内容是保持不变的。这对于性能来说，无疑是十分差的。</p>\n<p>那么有没有一种办法，能够让浏览器进行局部的回流重绘，从而达到优化性能的目的呢？或者说，减少回流时产生的性能消耗。答案是有的，就是今天所要认识的 <em>CSS Containment</em></p>\n<h1 id=\"css-containment\">CSS Containment</h1>\n<blockquote>\n<p>CSS Containment 主要是通过允许开发者将某些子树从页面中独立出来，从而提高页面的性能。如果浏览器知道页面中的某部分是独立的，就能够优化渲染并获得性能提升。</p>\n</blockquote>\n<p>由于有很多的交互或者复杂的情况，需要触发回流，重新渲染整个页面。为了改进这个，浏览器必须识别有哪些部分是独立的。当他们的子元素有变化时，浏览器的渲染引擎能够识别到，只对部分元素做回流重绘，而不对整个页面进行。</p>\n<p>识别这个标准的属性就是 <code>contain</code> 。</p>\n<h2 id=\"contain\">contain</h2>\n<p>通过 <code>contain</code> 属性告诉浏览器，这些节点是独立的。</p>\n<h2 id=\"语法\">语法：</h2>\n<pre><code class=\"language-javascript\">div {\n  contain: none; /* 表示元素将正常渲染，没有包含规则 */\n  contain: layout; /* 表示元素外部无法影响元素内部的布局，反之亦然 */\n  contain: paint; /* 表示这个元素的子孙节点不会在它边缘外显示。如果一个元素在视窗外或因其他原因导致不可见，则同样保证它的子孙节点不会被显示。 */\n  contain: size; /* 表示这个元素的尺寸计算不依赖于它的子孙元素的尺寸 */\n\n  contain: content; /* 等价于 contain: layout paint */\n  contain: strict; /* 等价于 contain: size layout paint */\n}\n</code></pre>\n<p><a href=\"https://codepen.io/zaoei/pen/MWyJrwN\">一个例子</a></p>\n<h3 id=\"layout\">Layout</h3>\n<blockquote>\n<p>This value turns on layout containment for the element. This ensures that the containment box is totally opaque for layout purposes; nothing outside can affect its internal layout, and vice versa.</p>\n</blockquote>\n<p>设置了 <code>layout</code> 属性，就是告诉浏览器当前元素内部的样式变化不会引起元素外部的样式变化。并且，元素外部的样式变化也不会引起元素内部的样式变化。这样，浏览器就可以相应的减少渲染元素，提高渲染的性能。</p>\n<p>如果设置了 <code>layout</code> 属性的元素，被遮挡，如屏幕外。则浏览器会把该元素相关的处理，放到较低的优先级中。</p>\n<pre><code class=\"language-javascript\">.container li {\n    padding: 10px;\n    height: 100px;\n\n    contain: layout;\n}\n</code></pre>\n<p><img alt=\"8fcea485affb42fe9f173f2c26f07691_tplv-k3u1fbpfcp-watermark.gif\" src=\"https://blog.palashsh.me/assets/images/8fcea485affb42fe9f173f2c26f07691_tplv-k3u1fbpfcp-watermark-ee44f9037973043fe2d3a32a7016ad6d.gif\" width=\"1740\" height=\"1002\">\n值得注意的是，由于元素内部的样式变化，导致了元素本身发生了大小等能触发回流的属性时，那么 <code>layout</code> 属性将不生效。</p>\n<h3 id=\"paint\">Paint</h3>\n<blockquote>\n<p>This value turns on paint containment for the element. This ensures that the descendants of the containment box don’t display outside its bounds, so if an element is off-screen or otherwise not visible, its descendants are also guaranteed to be not visible.</p>\n</blockquote>\n<p>设置了 <code>paint</code> 属性，表示这个元素的子孙节点不会在它边缘外显示。如果一个元素在视窗外或因其他原因导致不可见，则同样它的子孙节点不会被显示。</p>\n<pre><code class=\"language-javascript\">.container li {\n    padding: 10px;\n    height: 100px;\n\n    contain: paint;\n}\n</code></pre>\n<p><img alt=\"51d4f10219664196bc024dc1d77267ea_tplv-k3u1fbpfcp-watermark.gif\" src=\"https://blog.palashsh.me/assets/images/51d4f10219664196bc024dc1d77267ea_tplv-k3u1fbpfcp-watermark-2ba179883ee92d97d12dcbc15ab87c57.gif\" width=\"1740\" height=\"1002\"></p>\n<p>对于子元素，部分内容超出边界，那么该部分内容也不会被渲染。</p>\n<p>从效果上来看，这有点类似于 <code>overflow：hidden</code>，不同的是 <code>overflow：hidden</code>，是通过将超出部分进行裁剪的方式。</p>\n<p>举个例子，对于有滚动条的元素，由于滚动，会触发多次渲染，这些渲染的元素，包含当前可视区外的元素，造成了性能浪费。而使用 <code>paint</code> 就可以忽略这些可视区外元素的渲染，从而达到优化渲染性能。</p>\n<h3 id=\"size\">Size</h3>\n<blockquote>\n<p>The value turns on size containment for the element. This ensures that the containment box can be laid out without needing to examine its descendants.</p>\n</blockquote>\n<p>设置了 <code>size</code> 属性的元素，表示这个元素的尺寸计算不依赖于它的子孙元素的尺寸。</p>\n<p>对于浏览器来说，设置 <code>size</code> 就是告诉浏览器，这个元素的大小已经固定了，就是这么大，不需要再通过重排子元素来获取当前元素的大小。</p>\n<p>设置了 size 属性的元素，不管子元素是怎么布局，什么样式，都不会影响到父元素。</p>\n<pre><code class=\"language-javascript\">.container li {\n    padding: 10px;\n    height: 100px;\n\n    contain: size;\n}\n</code></pre>\n<p><img alt=\"0924d1088eb14169aad0ff98385f8d61_tplv-k3u1fbpfcp-watermark.gif\" src=\"https://blog.palashsh.me/assets/images/0924d1088eb14169aad0ff98385f8d61_tplv-k3u1fbpfcp-watermark-beaca27992211713e57358af51c9204f.gif\" width=\"1740\" height=\"1002\"></p>\n<p>使用这个 size 属性，会改变渲染的根结点，从而达到优化的目的</p>\n<p>使用前：</p>\n<p><img alt=\"72a3802ea8974ff38015b8ebddca20e2_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/72a3802ea8974ff38015b8ebddca20e2_tplv-k3u1fbpfcp-watermark-9ffcb2a873ef70a5b3072991750e5957.png\" width=\"362\" height=\"284\"></p>\n<p>使用后：</p>\n<p><img alt=\"80e954e5633a48819801688899a3557a_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/80e954e5633a48819801688899a3557a_tplv-k3u1fbpfcp-watermark-92740c7f91aecd2052314f137992fd3b.png\" width=\"592\" height=\"278\"></p>\n<p>可以看到，<em>layout root</em> 是完全不同的，前者基于 <em>document</em> 整个页面，而后者是基于当前的 <em>contain</em> 容器元素。</p>\n<p>在日常使用中，我们可以对一些容器元素使用，避免因为容器内部的布局改变，而导致整个页面的回流。</p>\n<h3 id=\"content--strict\">content &amp;&amp; strict</h3>\n<blockquote>\n<p>contain：content； // 表示这个元素上有除了 size 和 style 外的所有包含规则。等价于 contain: layout paint。</p>\n</blockquote>\n<blockquote>\n<p>contain：strict； // 表示除了 style 外的所有的包含规则应用于这个元素。等价于 contain: size layout paint。</p>\n</blockquote>\n<h2 id=\"布局\">布局</h2>\n<p>不知道大家是否注意到，设置了<code>contain</code>的元素，只有在明确了<code>width</code>, <code>height</code>的情况下，才会产生效果，否则就跟正常元素一样。</p>\n<p>真的没有其他任何变化么？其实不是的。</p>\n<p>只要设置了<code>contain</code>的元素，就类似于使用 <code>position：relative</code> 布局，不同的是，<code>z-index</code>，以及<code>top</code>、<code>left</code>等改变位置的属性对其自身是无效。</p>\n<p>对于设置<code>contain: layout</code>，通过观察可以看到，观感上它与 <code>position：relative</code> 并无区别，都是在正常文档流中占据位置，且子元素浮于正常文档流之上。</p>\n<p><img alt=\"cfcbe61cf942471aa2efc4d5ef456caf_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/cfcbe61cf942471aa2efc4d5ef456caf_tplv-k3u1fbpfcp-watermark-63676f9bb2e972a617e8b3d6d437b124.png\" width=\"920\" height=\"738\"></p>\n<p>但是，对于设置<code>contain: size</code>的元素，通过观察可以看到，它也是在正常文档流中占据位置，不同的是，子元素浮于正常文档流之下，这就可以说明，只要设置了<code>contain: size</code>，它的层级是低于正常文档流的。</p>\n<p><img alt=\"0c67a7b87772410ab632ca14e3ff0dd7_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/0c67a7b87772410ab632ca14e3ff0dd7_tplv-k3u1fbpfcp-watermark-afc1e6ad4dc5c0ba771ca3f424db588d.png\" width=\"1116\" height=\"760\"></p>\n<h2 id=\"example\">example</h2>\n<p>为了更直观的看出 contain 的效果，先附上 <a href=\"https://blogs.igalia.com/mrego/files/2019/01/css-contain-example.html\">Manuel Rego Casasnovas</a> 写的例子。</p>\n<pre><code class=\"language-javascript\">window.performance.now(); // 返回一个表示从性能测量时刻开始经过的毫秒数\n</code></pre>\n<p>通过<code>[window.performance.now()](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now)</code>记录回流的开始时间，在回流结束后再通过<code>[window.performance.now()](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now)</code>记录一次结束时间，用得到的开始时间和结束时间相减，就得到了一次完整回流所经历的时间。</p>\n<pre><code class=\"language-javascript\">function runTests() {\n  setup(); // 创建 1000 个节点\n\n  let avg1 = changeTargetContent(); // 没有设置contain，触发回流\n\n  let targetItem = document.getElementById('targetItem');\n  targetItem.style.contain = 'strict';\n  let avg2 = changeTargetContent(); // 触发回流\n}\n\nfunction changeTargetContent() {\n  // Force layout.\n  document.body.offsetLeft;\n\n  let start = window.performance.now();\n\n  let targetInner = document.getElementById('targetInner');\n  targetInner.textContent = targetInner.textContent == 'Hello World!' ? 'BYE' : 'Hello World!';\n\n  // Force layout.\n  document.body.offsetLeft;\n\n  let end = window.performance.now();\n  let time = end - start;\n  return time;\n}\n</code></pre>\n<p><img alt=\"06f9f39a3c57410f91a45facd5d1fd11_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/06f9f39a3c57410f91a45facd5d1fd11_tplv-k3u1fbpfcp-watermark-3e8d3cd3cdf13ff345322f961f2ef5a1.png\" width=\"1500\" height=\"934\"></p>\n<p>通过对比<code>cantain: strict</code>设置前和设置后，可以看到性能的优化达到了 80%左右。</p>\n<p>在实际项目里下，使用<code>cantain: strict</code>属性后的效果。\n截图场景，点击了 2 次按钮，完整触发了一个模块的打开关闭，前者为使用前，后者为使用后的的实际渲染效果。</p>\n<p>使用前：\n<img alt=\"b8573215f2e94537b35d76070c2551fd_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/b8573215f2e94537b35d76070c2551fd_tplv-k3u1fbpfcp-watermark-af7b3f189a697859eedfd3509aea7ef7.png\" width=\"1500\" height=\"575\"></p>\n<p>使用后：\n<img alt=\"22847cd41ac042a5ae8f8a562543d8a2_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/22847cd41ac042a5ae8f8a562543d8a2_tplv-k3u1fbpfcp-watermark-9ddf421ded1e7d2b719d578caee82bc3.png\" width=\"1500\" height=\"586\"></p>\n<p>通过比较，可以看出使用 <code>cantain: strict</code> 后，rendering 时长从 1750ms 降至 558ms，优化了 60%左右。而 painting 时长从 230ms 降至 35ms，优化了 75%的左右。</p>\n<p>rendering 和 Painting 的占用时间，都有非常明显的减少。使用后对渲染性能的优化还是非常明显的。</p>\n<h2 id=\"兼容性\">兼容性</h2>\n<p><img alt=\"79f1995d73f94a0d8a727b2ec70160f9_tplv-k3u1fbpfcp-watermark.png\" src=\"https://blog.palashsh.me/assets/images/79f1995d73f94a0d8a727b2ec70160f9_tplv-k3u1fbpfcp-watermark-b824859a1560102c1b02554e7518852e.png\" width=\"1500\" height=\"454\"></p>\n<h1 id=\"写在最后\">写在最后</h1>\n<p>在本次的学习中，其实还有一些值得探究或者比较遗憾的地方：</p>\n<ul>\n<li><code>contain</code>在优化页面渲染性能的情况下，是否给浏览器带来了其他负担？个人猜测是通过空间换时间的方式。</li>\n<li>设计的 demo 的实际效果跟理想中的效果，并不一致，不免有些遗憾。如对于 <code>contain：paint</code> 来说，在屏幕外添加子节点，触发回流重绘，根据<code>contain：paint</code>属性在屏幕外，不绘制元素的特性，重绘的时间应该是非常小，或者将近 0ms 的，然而在实际中并没有达到这个效果。</li>\n</ul>\n<p>如果文章中出现错误，或者有更好的验证 demo，欢迎留言交流哈 😊。</p>\n<h1 id=\"参考文献\">参考文献</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Containment\">CSS Containment</a></li>\n<li><a href=\"https://developers.google.com/web/updates/2016/06/css-containment\">CSS Containment in Chrome 52</a></li>\n<li><a href=\"https://css-tricks.com/almanac/properties/c/contain/\">CSS-Tricks</a></li>\n<li><a href=\"https://caniuse.com/?search=contain\">caniuse</a></li>\n<li><a href=\"https://blogs.igalia.com/mrego/2019/01/11/an-introduction-to-css-containment/\">An introduction to CSS Containment</a></li>\n<li><a href=\"https://www.w3.org/TR/css-contain-1/\">CSS Containment Module Level 1</a></li>\n<li><a href=\"https://www.w3.org/TR/css-contain-2/\">CSS Containment Module Level 2</a></li>\n</ul>",
            "url": "https://blog.palashsh.me/Containment_",
            "title": "渲染优化之CSS Containment.md",
            "summary": "在开始介绍今天的主角 CSS Containment 之前，我们需要了解一些前置知识回流和重绘，方便我们理解以及应用的场景。",
            "date_modified": "2021-07-16T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "css",
                "optimize"
            ]
        },
        {
            "id": "https://blog.palashsh.me/attributeFeature",
            "content_html": "<p><strong>对象属性是由名字、值和一组特性（attribute）构成。</strong></p>\n<p>在 javaSctipr 中，属性的值可以用一个或两个方法代替，分别是 getter 和 setter,除了这两个方法之外，属性还包含一些标识他们可写，可枚举和可配置的的特性。</p>\n<p>ECMAScript 5 中定义了一个名为“属性描述符”（property descriptor）的对象，用这个对象代表属性的特性。\n属性描述符分为两种：</p>\n<ul>\n<li>数据属性：value(值)、writale(可写性)、enumerable(可枚举性)和 configurable(可配置性)。</li>\n<li>存取性属性：getter 和 setter.</li>\n</ul>\n<h2 id=\"数据属性\">数据属性</h2>\n<p>数据属性的 4 个特性分别为它的值（value）, 可写性（writable），可枚举性（enumerable）和可配置性（configurble）。\n数据属性的描述符对象的属性：</p>\n<pre><code class=\"language-javascript\">value; // 值\nwritable; // 可写性\nenumerable; // 可枚举性\nconfigurble; // 可配置性\n</code></pre>\n<p>其中 writable、enumerable 和 configurble 都是布尔值。</p>\n<h3 id=\"value值\">value(值)</h3>\n<pre><code class=\"language-javascript\">var obj = {}; // 定义一个对象\nObject.defineProperty(obj, 'name', {\n  value: 'Zaoei'\n}); // 设置一个name属性，并设置值\nobj.name; // Zaoei\n</code></pre>\n<h3 id=\"writable可写性\">writable(可写性)</h3>\n<pre><code class=\"language-javascript\">var obj = {}; // 定义一个对象\nObject.defineProperty(obj, 'name', {\n  value: 'Zaoei'\n}); // 设置一个name属性，并设置值,并具有可写性\nconsole.log(obj.name); // Zaoei\nobj.name = 1; // 改变值\nconsole.log(obj.name); // 1\n\nObject.defineProperty(obj, 'name', {\n  writable: false\n}); // 把name属性的可写性设置为false\nobj.name = 'Zaoei'; // 改变值，由于设置了可写性为false,虽然不报错，但是值未改变。\nconsole.log(obj.name); // 1 ，值不变\n</code></pre>\n<h3 id=\"enumerable可枚举性\">enumerable(可枚举性)</h3>\n<pre><code class=\"language-javascript\">var obj = {}; // 定义一个对象\nObject.defineProperty(obj, 'name', {\n  value: 'Zaoei',\n  enumerable: true\n}); // 设置一个name属性，并设置值,并具有可枚举性\nconsole.log(Object.keys(obj)); // [\"name\"]\nObject.defineProperty(obj, 'name', {\n  enumerable: false\n}); // 把name属性的可枚举性设置为false\nconsole.log(Object.keys(obj)); // []\nfor (var key in obj) {\n  console.log(key);\n} // 使用for循环也遍历不到name属性\n</code></pre>\n<h3 id=\"configurable可配置性\">configurable(可配置性)</h3>\n<pre><code class=\"language-javascript\">var o = {};\nObject.defineProperty(o, 'age', {\n  value: 18,\n  writable: true,\n  enumerable: true,\n  configurable: false\n}); // 设置可配置性为false\no.age = 1; // 修改值\nconsole.log(o.age); // 1，修改成功\nconsole.log(Object.keys(o)); // [\"age\"] 枚举成功\ndelete o.age; // 删除age属性\nconsole.log(o); // {age:1} 删除属性失败\nObject.defineProperty(o, 'age', {\n  value: 1000,\n  writable: false,\n  enumerable: false,\n  configurable: true\n}); // 设置对象的特性，直接报错\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20210321115858120.png\" alt=\"在这里插入图片描述\">\n可以看到一旦对属性的可配置性设置为 false,就不能对这个属性特性进行任何的修改，<a href=\"https://blog.palashsh.me/attributeFeature#_153\">详细规则请看最下</a>。</p>\n<h2 id=\"存取器属性\">存取器属性</h2>\n<p>由 getter 和 setter 定义的属性称为“存取器属性”，它们都是函数值。存取器属性的描述符对象则用 get 和 set 属性代替 value 和 writable。</p>\n<h3 id=\"getter\">getter</h3>\n<p>当程序查询存取器的值时，JavaScript 调用 getter 方法（无参数），这个方法返回的值，就是属性存取表达式返回的值。</p>\n<pre><code class=\"language-javascript\">var obj = {};\nObject.defineProperty(obj, 'name', {\n  get: function () {\n    return '张三';\n  }\n});\nconsole.log(obj.name); // 张三\n</code></pre>\n<h3 id=\"setter\">setter</h3>\n<p>当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当作参数传入 setter。\n<img src=\"https://img-blog.csdnimg.cn/20210321122947482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjExNzU1OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"获取属性描述符\">获取属性描述符</h2>\n<h3 id=\"objectgetownpropertydescriptorobj-name\">Object.getOwnPropertyDescriptor(obj, name)</h3>\n<p>通过调用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\">Object.getOwnPropertyDescriptor()</a>可以获得某个对象特点属性的属性描述符。</p>\n<pre><code class=\"language-javascript\">/*\n *参数1：需要查找的目标对象\n *参数2：目标对象内属性名称\n *\n *Object.getOwnPropertyDescriptor只能得到自由属性的描述符。\n */\nObject.getOwnPropertyDescriptor(obj, 'name'); // {value: 1, writable: true, enumerable: true, configurable: true}\n</code></pre>\n<h2 id=\"设置属性描述符\">设置属性描述符</h2>\n<h3 id=\"objectdefineprtperty\">Object.defineprtperty()</h3>\n<p>通过调用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty()</a>，传入要修改的对象、要创建或修改的属性名以及属性描述符对象。</p>\n<pre><code class=\"language-javascript\">/*\n *参数1：要定义属性的对象。\n *参数2：要定义或修改的属性的名称或 Symbol 。\n *参数3：要定义或修改的属性描述符。\n *\n *属性描述符的的默认值不是undefined就是false.\n */\nObject.defineProperty(obj, 'attributeName', {\n  value: undefined,\n  writable: false,\n  enumerable: false,\n  conficgurable: false\n});\n</code></pre>\n<h3 id=\"objectdefineporpertiesobj-props\">Object.definePorperties(obj, props)</h3>\n<p>通过使用 Object.defineProperties()方法，同时修改或创建多个属性。</p>\n<pre><code class=\"language-javascript\">/*\n *参数1：在其上定义或修改属性的对象。\n *参数2：要定义其可枚举属性或修改的属性描述符的对象。\n */\nObject.defineProperties(obj, {\n  attrName1: { value: '张三', writable: true, enumerable: true, configurable: true },\n  attrName2: { value: '李四', writable: true, enumerable: true, configurable: true }\n});\n</code></pre>\n<h3 id=\"规则\">规则</h3>\n<p>Object.definePorperty()和 Object.defineProperties()的详细规则，不符合则直接报错。</p>\n<blockquote>\n<ul>\n<li>如果对象是不可拓展的，则可以编辑已有的自有属性，但不能给它添加新属性；</li>\n<li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性；</li>\n<li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性；</li>\n<li>如果数据属性是不可配置的，则不能将它转换成存取器属性；</li>\n<li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true,但可以从 true 修改为 false;</li>\n<li>如果数据属性是不可配置且不可写的，则不能修改它的值。</li>\n<li>如果属性是可以配置，但不可写的，属性的值是可以调用方法 Object.defineProperty 和 Object.defineProperties()修改的（实际上是先将它标记为可写的，然后修改他的值，最后转换为不可写的）</li>\n</ul>\n</blockquote>\n<h1 id=\"资料参考\">资料参考</h1>\n<blockquote>\n<p>《JavaScript 权威指南》\nMDN web 文档</p>\n</blockquote>",
            "url": "https://blog.palashsh.me/attributeFeature",
            "title": "属性特性",
            "summary": "对象属性是由名字、值和一组特性（attribute）构成。",
            "date_modified": "2020-04-18T00:00:00.000Z",
            "author": {
                "name": "赵炜",
                "url": "https://github.com/Zaoei"
            },
            "tags": [
                "design"
            ]
        }
    ]
}