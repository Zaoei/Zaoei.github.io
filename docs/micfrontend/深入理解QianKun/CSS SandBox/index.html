<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-micfrontend/深入理解QianKun/CSS SandBox/CSS SandBox" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">CSS SandBox | Zaoei Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" property="og:url" content="https://blog.palashsh.me/docs/micfrontend/深入理解QianKun/CSS SandBox/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:image" content="https://avatars.githubusercontent.com/u/35087196?v=4"><meta data-rh="true" name="twitter:card" content="https://avatars.githubusercontent.com/u/35087196?v=4"><meta data-rh="true" name="twitter:image" content="https://avatars.githubusercontent.com/u/35087196?v=4"><meta data-rh="true" name="twitter:site" content="@battleofplassey"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="CSS SandBox | Zaoei Blog"><meta data-rh="true" name="description" content="本篇文章主要介绍的是关于CSS Sandbox的一些事情，为什么要介绍这个呢？在我们日常的开发中，样式问题其实一直是一个比较耗时的事情，一方面我们根据UI稿不断的去调整，另一方面随着项目越来越大可能哪一次开发就发现——诶，我的样式怎么不起作用了，亦或是怎么被另一个样式所覆盖了。原因可能有很多："><meta data-rh="true" property="og:description" content="本篇文章主要介绍的是关于CSS Sandbox的一些事情，为什么要介绍这个呢？在我们日常的开发中，样式问题其实一直是一个比较耗时的事情，一方面我们根据UI稿不断的去调整，另一方面随着项目越来越大可能哪一次开发就发现——诶，我的样式怎么不起作用了，亦或是怎么被另一个样式所覆盖了。原因可能有很多："><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.palashsh.me/docs/micfrontend/深入理解QianKun/CSS SandBox/"><link data-rh="true" rel="alternate" href="https://blog.palashsh.me/docs/micfrontend/深入理解QianKun/CSS SandBox/" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.palashsh.me/docs/micfrontend/深入理解QianKun/CSS SandBox/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://2KDKKFPT4A-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Zaoei Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Zaoei Blog Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="Zaoei Blog JSON Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R5V7R63B0J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-R5V7R63B0J",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Zaoei Blog" href="/opensearch.xml">
<link rel="icon" href="/img/docusaurus.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(37, 194, 160)"><link rel="stylesheet" href="/assets/css/styles.09761036.css">
<script src="/assets/js/runtime~main.d0e4631e.js" defer="defer"></script>
<script src="/assets/js/main.46e122de.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Zaoei Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.png" alt="Zaoei Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" link="blog" href="/">Blog</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" link="doc" doclink="docs/webpack-resolve/README.md" href="/docs/webpack-resolve/">docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Zaoei" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" externallink="https://github.com/Zaoei" link="external" aria-label="GitHub repository"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><img src="/img/logo.png" alt="Zaoei Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.png" alt="Zaoei Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"><b></b></a><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/algorithm">algorithm</a><button aria-label="Expand sidebar category &#x27;algorithm&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/micfrontend">micfrontend</a><button aria-label="Collapse sidebar category &#x27;micfrontend&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/">README</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/design/">design</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/micfrontend/practice/">qiankun 实践</a><button aria-label="Expand sidebar category &#x27;qiankun 实践&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/micfrontend/深入理解QianKun/CSS SandBox/">深入理解QianKun</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/micfrontend/深入理解QianKun/CSS SandBox/">CSS SandBox</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/深入理解QianKun/JS SandBox/">JS SandBox</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/深入理解QianKun/Load、Prefetch and Communication/">加载流程、预加载以及通信</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/深入理解QianKun/Review &amp;&amp; Summary/">回顾和总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/micfrontend/深入理解QianKun/Route/">single-spa中的路由实现</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/operating-system">operating system</a><button aria-label="Expand sidebar category &#x27;operating system&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/single sign on/CAS">single sign on</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/webpack-optimize">webpack-optimize</a><button aria-label="Expand sidebar category &#x27;webpack-optimize&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/webpack-resolve">webpack-resolve</a><button aria-label="Expand sidebar category &#x27;webpack-resolve&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/whoami">whoami</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/micfrontend"><span itemprop="name">micfrontend</span></a><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">深入理解QianKun</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">CSS SandBox</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1 id="css-sandbox">CSS SandBox</h1>
<h1 id="引言">引言</h1>
<p>本篇文章主要介绍的是关于<code>CSS Sandbox</code>的一些事情，为什么要介绍这个呢？在我们日常的开发中，样式问题其实一直是一个比较耗时的事情，一方面我们根据UI稿不断的去调整，另一方面随着项目越来越大可能哪一次开发就发现——诶，我的样式怎么不起作用了，亦或是怎么被另一个样式所覆盖了。原因可能有很多：</p>
<ul>
<li>不规范的命名导致重复</li>
<li>为了简单，直接添加全局样式的修改</li>
<li>样式的不合理复用</li>
<li>多个项目合并时，每个子项目都有自己的独立样式和配置，可能在自己项目中不存在这样的问题，但是合并以后互相影响造成了样式污染</li>
<li>第三方框架引入</li>
<li>……</li>
</ul>
<p>而<code>CSS Sandbox</code>正式为了隔离样式，从而解决样式污染的问题</p>
<h1 id="应用场景">应用场景</h1>
<p>通过上述我们了解了样式污染产生的原因，从中我们也可以总结一下哪些场景时我们需要使用<code>CSS Sandbox</code>进行样式隔离呢</p>
<ul>
<li>微前端场景下的父子以及子子应用</li>
<li>大型项目以及复杂项目的样式冲突</li>
<li>第三方框架以及自定义主题样式的覆盖</li>
<li>……</li>
</ul>
<h1 id="常见的解决方案">常见的解决方案</h1>
<p>既然说了这么多样式污染产生的原因和应用场景，那我们该如  何解决他们呢，目前有以下几种解决方案，其实解决的核心还是不变的——<code>使CSS选择器作用的Dom元素唯一</code></p>
<p><img alt="Untitled" src="/assets/images/实现样式沙箱的方式-8b9702907f0e7752cceeaedf93634766.png" width="1734" height="998"></p>
<p>Tips：当我们在实际的开发中可以根据项目的实际情况进行选择</p>
<h2 id="css-in-js">CSS in JS</h2>
<p>看名字是不是感觉很高级，直译下就是用JS去写CSS样式，而不是写在单独的样式文件里。例如：</p>
<pre><code class="language-tsx">&lt;p style=&#x27;color:red&#x27;&gt;css in js&lt;/p&gt;
</code></pre>
<p>这和我们传统的开发思想很不一样，传统的开发原则是<code>关注点分离</code>，就比如我们常说的不写<code>行内样式</code>、<code>行内脚本</code>，即HTML、JS、CSS都写在对应的文件里。</p>
<p>关于CSS in JS不是一个新兴的技术，他的热度主要出现于一些Web框架的发展，比如说：React，它所支持的jsx语法，可以让我们在一个文件中同时写js、html和css，并且<code>组件</code>内部管理自己的样式、逻辑，组件化开发的思想深入人心。</p>
<pre><code class="language-tsx">const style = {
	color: &#x27;red&#x27;
}

ReactDOM.render(
  &lt;p style={style}&gt;
     css in js
  &lt;/h1&gt;,
  document.getElementById(&#x27;main&#x27;)
);
</code></pre>
<p>每个组件的样式由自身的style决定，不依赖也不影响外部，从这一点来看确实实现了样式隔离的效果。</p>
<p>关于<code>Css in js</code>的库也有很多，比如说：</p>
<ul>
<li><a href="https://styled-components.com/docs">styled-components</a></li>
<li><a href="https://polished.js.org/">polished</a></li>
<li>······</li>
</ul>
<p>其中styled-components会动态生成一个选择器</p>
<pre><code class="language-tsx">import styled from &#x27;styled-components&#x27;

function App() {
  const Title = styled.h1`
    font-size: 1.5em;
    text-align: center;
    color: palevioletred;
  `;

  return (
    &lt;div&gt;
      &lt;Title&gt;Hello World, this is my first styled component!&lt;/Title&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><img alt="Untitled" src="/assets/images/styled-components-d2ba10d0c4cfdab7e50e3d24aab0e4d1.png" width="3004" height="1486"></p>
<h3 id="优缺点">优缺点</h3>
<p>| 优点 | • 没有作用域的样式污染问题（主要指的是通过写内行样式以及生成唯一的css选择器）
• 减少了无用样式的堆积，删除组件即删除对应的样式
• 通过导出定义的样式变量方便进行复用和重构 |
| --- | --- |
| 缺点 | • 内联样式不支持伪类和选择器等写法
• 代码的可读性比较差，违背了关注点分离的原则
• 运行时会消耗性能，动态生成css（我们在写css时其实还是js）
• 不能结合一些CSS预处理器，无法进行预编译 |</p>
<h2 id="样式约定">样式约定</h2>
<p>通过约应用的命名前缀实现统一的开发和维护，比如说BEM的命名方式，通过对块、元素以及修饰符三者的命名来规范的描述一个组件</p>
<pre><code class="language-tsx">.dropdown-menu__item-button--disabled
</code></pre>
<h3 id="优缺点-1">优缺点</h3>
<p>| 优点 | • 样式隔离
• 语义化强，组件可读性高 |
| --- | --- |
| 缺点 | • 命名太长
• 依赖于开发者的命名 |</p>
<h2 id="预处理器">预处理器</h2>
<p>通过css预处理器可以处理很多独特的语法格式，比如：</p>
<ul>
<li>可嵌套性</li>
</ul>
<pre><code class="language-sass">body {
	with: 20px;
	p {
		color: red;
	}
}
</code></pre>
<ul>
<li>父选择器</li>
</ul>
<pre><code class="language-sass">body {
	with: 20px;
	&amp;:hover {
		with: 30px;
	}
}
</code></pre>
<ul>
<li>属性继承</li>
</ul>
<pre><code class="language-less">.dev {
	width: 200px;
}

span {
	.dev
}
</code></pre>
<ul>
<li>......</li>
</ul>
<p>通过这些特殊的语法让css更容易解读和维护</p>
<p>一些常见的市场上的预处理器</p>
<ul>
<li>Sass</li>
<li>Less</li>
<li>Stylus</li>
<li>PostCss</li>
<li>......</li>
</ul>
<h3 id="优缺点-2">优缺点</h3>
<p>| 优点 | • 可读性较好，方便理解和维护dom结构
• 利用嵌套等方式，也可以大幅度解决样式污染的问题 |
| --- | --- |
| 缺点 | •需要增加额外的包，借助相关编译工具 |</p>
<p>Tips：通常与类似于BEM的命名方式结合，可以达到提高开发效率，增强可读性以及复用的效果</p>
<h2 id="css-module">CSS Module</h2>
<p>顾名思义就是将css进行模块化处理，编译好后可以避免样式被污染的问题，不过依赖于<strong>Webpack</strong>需要配置<code>css-loader</code>等打包工具，以下是我在<code>create-react-app</code>创建的项目中运行，由于其已经在webpack配置了<code>css-loader</code>，因此在此篇文章中不展示具体配置</p>
<p>index.ts文件</p>
<pre><code class="language-tsx">import style from &#x27;./style.module.css&#x27;

function App() {

  return (
    &lt;div&gt;
      &lt;p className={style.text}&gt;Css Module&lt;/p&gt;
    &lt;/div&gt;
  );
}

</code></pre>
<p>style.module.css文件</p>
<pre><code class="language-sass">.text {
  color: red;
}

// 等同于
:local(.text) {
    color: blue;
}

// 还有一种全局模式，此时不会进行编译
:global(.text) {
    color: blue;
}
</code></pre>
<p><img alt="Untitled" src="/assets/images/css-module-c1dae3a71ba0b4855fd57f960e9f6ffb.png" width="3014" height="1538"></p>
<p>打包工具会同时把style.text以及text编译成独一无二的值</p>
<h3 id="优缺点-3">优缺点</h3>
<p>| 优点 | • 学习成本较低，不依赖于人工约束
• 基本上能100%解决样式污染问题
• 方便实现模块的复用 |
| --- | --- |
| 缺点 | • 只能在构建时使用，依赖于css-loader等
• 可读性差，在控制台调试时出现hash值不方便调试 |</p>
<h2 id="shadow-dom">Shadow DOM</h2>
<p>它可以将一个隐藏、独立的DOM附加到一个元素上。当我们用Shadow DOM包裹一个元 素后，其内样式不会对外部样式造成影响，外部样式也不会对其内部造成影响</p>
<p><img alt="Untitled" src="/assets/images/shadowDom-a15aec72f79b6076ee3a29feb3dbf46f.png" width="2146" height="1378"></p>
<pre><code class="language-tsx">// 创建一个shadow dom，我这里是通过ref去拿附着的节点，一般可以用document去拿
import &#x27;./App.css&#x27;; // 定义了shadow-text的样式

function App() {
  const divRef = useRef(null)

  useEffect(() =&gt; {
    if(divRef?.current) {
      const { current } = divRef
      const shadow = current.attachShadow({mode: &#x27;open&#x27;}); // mode用来控制能否用js获取shaow dom内的元素
      shadow.innerHTML = &#x27;&lt;p className=&quot;shadow-text&quot;&gt;Here is some new text&lt;/p&gt;&#x27;;
      console.log(current.shadowRoot)
    }
  }, [])

  return (
    &lt;div&gt;
      &lt;div ref={divRef} className=&#x27;shadow-host&#x27;&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}

</code></pre>
<p><img alt="Untitled" src="/assets/images/shadowDom例子1-2a11532d196f7778e271a3d5a9f0dba0.png" width="2950" height="1356"></p>
<p>外部样式无法影响shadow dom内部的样式</p>
<p>我们再来看下shadow dom内部得样式会影响外部样式吗？</p>
<pre><code class="language-tsx">function App() {
  useEffect(() =&gt; {
    if(divRef?.current) {
      const { current } = divRef
      const shadow = current.attachShadow({mode: &#x27;open&#x27;});
      shadow.innerHTML = &#x27;&lt;style&gt;.shadow-h1 { color: red } &lt;/style&gt;&lt;p class=&quot;shadow-h1&quot;&gt;Here is some new text&lt;/p&gt;&#x27;;
      
    }
  }, [])

  return (
    &lt;div&gt;
      &lt;Title&gt;Hello World, this is my first styled component!&lt;/Title&gt;
      &lt;h1 className=&#x27;shadow-h1&#x27;&gt;lalla1&lt;/h1&gt;
      &lt;div ref={divRef} className=&#x27;shadow-host&#x27;&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p><img alt="Untitled" src="/assets/images/shadowDom例子2-35e5e8ba89bc9859a5c895ec823b6ad4.png" width="2974" height="1442"></p>
<p>但是也有例外，除了<code>[:focus-within](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within)</code></p>
<pre><code class="language-tsx">import { useEffect, useRef } from &#x27;react&#x27;
import &#x27;./App.css&#x27;; // .shadow-host:focus-within { background-color: yellow;}

function ShadowExample() {
  const divRef = useRef(null)

  useEffect(() =&gt; {
    if(divRef?.current) {
      const { current } = divRef
      const shadow = current.attachShadow({mode: &#x27;open&#x27;});
      shadow.innerHTML = &#x27;&lt;input class=&quot;shadow-h1&quot;/&gt;&#x27;;
      
    }
  }, [])

  return (
    &lt;div&gt;
      &lt;p&gt;Css Module&lt;/p&gt;
      &lt;div ref={divRef} className=&#x27;shadow-host&#x27;&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}

export default ShadowExample;
</code></pre>
<p><img alt="Untitled" src="/assets/images/shadowDom例子3-7470b63a5594d8dcd8229ee409d58fe9.png" width="2318" height="1384"></p>
<h3 id="问题">问题：</h3>
<p>正由于<code>shadow dom</code>内的样式只会应用于内部，如果我们在shadow dom内部用了类似于<code>antd</code>的<code>Modal</code>这些创建于<code>document.body</code>下的弹窗或者其他组件时，无法应用于<code>antd</code>的样式，需要把<code>antd</code>的样式放到上一层中。</p>
<h3 id="优缺点-4">优缺点</h3>
<p>| 优点 | • 不需要引入额外的包，浏览器原生支持
• 严格隔离 |
| --- | --- |
| 缺点 | • 在某些场景下可能出现样式失效的问题，如上问题中的shadow dom内创建了全局的Modal |</p>
<h1 id="浅析qiankun中的css-sandbox">浅析QianKun中的CSS SandBox</h1>
<p>上面我们讲解了一些实现样式隔离的基本方案，那作为一个比较成熟的微前端框架<code>QianKun</code>中又是怎么实现样式隔离方案的呢，以下的源码解析是在<code>v2.6.3</code>的版本上研究的，首先通过看文档可以发现</p>
<p><img alt="Untitled" src="/assets/images/qiankunApi-e0c677bb3a6b8f068a2ee67eb5ea418a.png" width="2086" height="146"></p>
<p>在QianKun中CSS SandBox有两种模式：</p>
<ul>
<li><code>strictStyleIsolation</code>——严格沙箱模式</li>
<li><code>experimentalStyleIsolation</code>——实验性沙箱模式</li>
</ul>
<h2 id="strictstyleisolation">strictStyleIsolation</h2>
<blockquote>
<p>需要注意的是该方案不是一个无脑的解决方案，开启后需要进行一定的适配</p>
</blockquote>
<p>下面我们来详细介绍下该模式：</p>
<p>我们设置<code>strictStyleIsolation</code>为<code>true</code>时，<code>QianKun</code>采用的是<code>Shadow DOM</code>方案，核心就是为每个微应用包裹上一个Shadow DOM节点。接下来我们看下是怎么实现的</p>
<p>先来个流程图我们有个大致的概念：</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation流程图-f40032414f2ecb9342efef2023e78a24.png" width="1158" height="1374"></p>
<ul>
<li><strong><code>registerMicroApps</code>：注册子应用，对未注册的应用进行记录，同时调用single-spa中的<code>registerApplication</code>进行注册</strong></li>
<li><code>loadApp</code>：加载子应用，初始化加载子应用的Dom结构，创建样式沙箱和JS沙箱等，同时返回不同阶段的生命周期</li>
<li><code>createElement</code>：样式沙箱的具体实现，主要分为两种<code>strictStyleIsolation</code>和<code>experimentalStyleIsolation</code></li>
</ul>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation1-4d7aba4f70f3dfbee2f51d7ddfc110cd.png" width="2412" height="1140"></p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation2-b2e152836b86acf4b58f3c25b06313cb.png" width="1772" height="844"></p>
<h3 id="registermicroapps注册子应用"><strong><strong>registerMicroApps：注册子应用</strong></strong></h3>
<pre><code class="language-tsx">export function registerMicroApps&lt;T extends ObjectType&gt;(apps: Array&lt;RegistrableApp&lt;T&gt;&gt;,lifeCycles?: FrameworkLifeCycles&lt;T&gt;,) {
...
    registerApplication({
      name,
      app: async () =&gt; {
        ...
        // 加载微应用的具体方法，暴露bootstrap、mount、unmount等生命周期以及一些其他配置信息
        const { mount, ...otherMicroAppConfigs } = (
          await loadApp({ name, props, ...appConfig }, frameworkConfiguration, lifeCycles)
        )();
				...
      },
      // 子应用的激活条件
      activeWhen: activeRule
			...
    });
  });
}
</code></pre>
<p>调用single-spa的registerApplication对应用进行注册，并且在应用激活的时候调用app的回调，其中最主要的是<code>loadApp</code>加载微应用的具体方法</p>
<p>一些参数的说明：</p>
<ul>
<li>
<p><code>apps</code>：微应用的注册信息</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation3-c89cdbe4ae5b1de30db3cfec7889e487.png" width="648" height="350"></p>
</li>
<li>
<p><code>lifeCycles</code>：微应用的一些生命周期钩子</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation4-b4e8a0ed5b4e6e360b1ed94c32252b60.png" width="1558" height="734"></p>
</li>
</ul>
<h3 id="loadapp加载子应用">loadApp：加载子应用</h3>
<pre><code class="language-tsx">function loadApp (app: LoadableApp&lt;T&gt;, configuration: FrameworkConfiguration = {},lifeCycles?: FrameworkLifeCycles&lt;T&gt;) {
...
/**
 * 将操作权交给主应用控制，返回结果涉及CSS SandBox和JS SandBox
 * template --template的为link替换为style注释script的HTML模版
 * execScripts --脚本执行器，让指定的脚本(scripts)在规定的上下文环境中执行，只做了解暂时不讲
 * assetPublicPath -- 静态资源地址，只做了解暂时不讲
 */
const { template, execScripts, assetPublicPath } = await importEntry(entry, importEntryOpts);

// 给子应用包裹一层div后的子应用html模版, 是模版字符串的形式
const appContent = getDefaultTplWrapper(appInstanceId)(template);

let initialAppWrapperElement: HTMLElement | null = createElement(
    appContent,
		// 是否开启了严格模式
    strictStyleIsolation,
		// 是否开启实验性的样式隔离
    scopedCSS,
		// 根据应用名生成的唯一值，唯一则为appName，不唯一则为appName_[count]为具体数量，重复会count++
    appInstanceId,
  );
...
// 下面还有一些生命周期的处理方法
}
</code></pre>
<p>Q1：到现在不知道还有没有人记得我们开启严格样式模式是需要做啥？</p>
<p>！！！把子应用的Dom结构放到Shadow dom中与主应用隔离，防止样式污染</p>
<p>Q2：那我们咋拿到子应用的dom结构呢？</p>
<p>没错就是通过<code>import-html-entry</code>库的<code>import-html-entry</code>方法，有兴趣给看下关于<a href="https://juejin.cn/post/6885212507837825038">import-html-entry解析</a></p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation5-909dc9cb1f1f63404bf81ccd95438164.png" width="2966" height="1082"></p>
<p>没错我们拿到了<code>template</code>、<code>execScripts</code>和<code>assetPublicPath</code>，这里我们不对后两个进行讲解，聚焦到<code>template</code>上：</p>
<p>对比下子应用原来的HTML结构</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation6-0df3292326eeb7c35d6efe9ae0aee3dd.png" width="1801" height="628"></p>
<p>可以发现我们拿到的<code>template</code>是<code>link</code>标签变成<code>style</code>标签注释了<code>script</code>的HTML模版，其中就有我们需要的子应用的Dom结构。</p>
<p>拿到以后QianKun里又在<code>template</code>上包裹了一层div形成一个新的HTML结构的模版字符串，这是为什么呢？主要是为了在主应用中标识该节点下的内容为子应用，当然在后面我们也需要它进行特别的处理，这个后面讲到的时候再说。因此我们现在拿到的<code>appContent</code>长成这个样子：</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation7-755cd43bfb1ae03ac67a420e8e5d403e.png" width="2690" height="848"></p>
<p>这个div的id是唯一的哈！！！</p>
<p>那我们现在是不是已经做好了前期准备，现在我们需要进入最后一个步骤，把子应用的这个Dom结构挂载到一个shadow dom上，这就要用到<code>createElement</code>方法。</p>
<p>进入<code>createElement</code>方法前我们先来看下目前的参数值：</p>
<ul>
<li>appContent：包裹了一层id唯一的div，具体如上所示</li>
<li>strictStyleIsolation：<code>true</code></li>
<li>scopedCSS：<code>false</code></li>
<li>appInstanceId：<code>react16</code></li>
</ul>
<h3 id="createelement添加shadow-dom">createElement：添加shadow dom</h3>
<p>那我们现在如何去创建一个shadow dom，在前面关于shadow dom的讲解中我们知道，创建一个shadow dom我们需要两个东西：</p>
<p>一、挂载的dom节点</p>
<p>二、需要添加到shadow dom的内容</p>
<p>那我们从哪里去找呢，根据传进来的参数吧，我们无疑是要对<code>appContent</code>进行处理了，回顾下<code>appContent</code>有什么，包裹了一层div的子应用的HTML模版是吧，自然而然的我们就可以以外面的div为挂载的dom节点，拿子应用的HTML模版为需要添加到shadow dom的内容，即：</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation8-bc268c416c51209d5c339a90df341eba.png" width="2438" height="832"></p>
<p>但是问题又来了， 目前的<code>appContent</code>是模版字符串嘞，我们咋办？这边QianKun的处理方案是：</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation9-4d0323c9692b77ac7f3dd02085218fdd.png" width="792" height="1378"></p>
<p>这只是个大致流程，下面让我们跟着这样的思想看下代码里处理：</p>
<pre><code class="language-tsx">function createElement(appContent: string,strictStyleIsolation: boolean,scopedCSS: boolean,appInstanceId: string) {
...
const containerElement = document.createElement(&#x27;div&#x27;);
  containerElement.innerHTML = appContent;
  const appElement = containerElement.firstChild as HTMLElement;
	// 严格样式沙箱模式
  if (strictStyleIsolation) {
    if (!supportShadowDOM) {
      console.warn(
        &#x27;[qiankun]: As current browser not support shadow dom, your strictStyleIsolation configuration will be ignored!&#x27;,
      );
    } else {
      const { innerHTML } = appElement;
      appElement.innerHTML = &#x27;&#x27;;
      let shadow: ShadowRoot;

			// 创建shadow dom节点
      if (appElement.attachShadow) {
        shadow = appElement.attachShadow({ mode: &#x27;open&#x27; });
      } else {
        // 兼容低版本
        shadow = (appElement as any).createShadowRoot();
      }
      shadow.innerHTML = innerHTML;
    }
  }
...
// 此处省略了开启experimentalStyleIsolation的处理方法
...
return appElement;
}
</code></pre>
<p>这里有个很有意思的是：</p>
<p>appContent以innerHTML变成dom结构后，HTML模版中的<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>以及<code>&lt;body&gt;</code>会被去掉</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation10-2da6059e6329caa9be3d77c6c01210bf.png" width="2910" height="1464"></p>
<p>最后我们再来看下子应用挂载到主应用的Dom结构：</p>
<p><img alt="Untitled" src="/assets/images/strictStyleIsolation11-26fc5e46711d13072ab2e3c6b5197fa1.png" width="1674" height="794"></p>
<p>笔者在实践的过程中也遇到了一些问题：</p>
<p>1、微应用中使用相对路径引入图片出现加载资源404的问题，这边笔者没有进行过多的尝试可以参考下官方的：<a href="https://qiankun.umijs.org/zh/faq#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%B5%84%E6%BA%90%E4%BC%9A-404">https://qiankun.umijs.org/zh/faq#为什么微应用加载的资源会-404</a></p>
<p>2、还有一个问题就是react中动态打开Modal失效的问题，原因可以看下‣，大概看了下和React的事件机制有关，即使是设置弹窗默认开启，也会出现之前上面提到的，样式丢失的问题</p>
<p>！！！看下一个之前简单回顾下吧—————————————————————————————————</p>
<h2 id="experimentalstyleisolation">experimentalStyleIsolation</h2>
<p>我们设置<code>experimentalStyleIsolation</code>为<code>true</code>时，<code>QianKun</code>采用的是<code>Runtime css transformer</code> 动态加载/卸载样式表方案，为子应用的样式表增加一个特殊的选择器从而限定影响范围，类似以下结构：</p>
<pre><code class="language-tsx">// 假设应用名是 react16
&lt;style&gt;
.app-main {
  font-size: 14px;
}
&lt;/style&gt;

&lt;style&gt;
div[data-qiankun=&quot;react16&quot;] .app-main {
  font-size: 14px;
}
&lt;style&gt;
</code></pre>
<p>先来通过流程图了解下大致  流程</p>
<p><img alt="111.png" src="/assets/images/experimentalStyleIsolation-5c37f0ce02e2ba50516fda33c13da802.png" width="3153" height="5106"></p>
<h3 id="createelement给最外层增加data-qiankun属性并且获取所有style标签">createElement：给最外层增加data-qiankun属性，并且获取所有style标签</h3>
<pre><code class="language-tsx">function createElement(appContent: string, strictStyleIsolation: boolean, scopedCSS: boolean,appInstanceId: string) {
...
if (scopedCSS) {
		// 给最外层设置data-qiankun的属性
    const attr = appElement.getAttribute(css.QiankunCSSRewriteAttr);
    if (!attr) {
      appElement.setAttribute(css.QiankunCSSRewriteAttr, appInstanceId);
    }
		// 获取所有的style标签,进行遍历
    const styleNodes = appElement.querySelectorAll(&#x27;style&#x27;) || [];
    forEach(styleNodes, (stylesheetElement: HTMLStyleElement) =&gt; {
      css.process(appElement!, stylesheetElement, appInstanceId);
    });
  }
...
}

export const QiankunCSSRewriteAttr = &#x27;data-qiankun&#x27;;
</code></pre>
<p>我们来看下设置完属性后的属性后的appElement</p>
<p><img alt="Untitled" src="/assets/images/experimentalStyleIsolation1-a7160cb7bb05a10b3927f30099116fdf.png" width="2242" height="494"></p>
<p>styleNodes</p>
<p><img alt="Untitled" src="/assets/images/experimentalStyleIsolation2-1b99f67e596eb294b766ab927c9a4309.png" width="692" height="110"></p>
<h3 id="cssprocess详细处理">css.process详细处理</h3>
<pre><code class="language-tsx">/**
* 实例化ScopedCSS
* 生成根元素属性选择器[data-qiankun=&quot;应用名&quot;]前缀
*/
export const process = (
  appWrapper: HTMLElement,
  stylesheetElement: HTMLStyleElement | HTMLLinkElement,
  appName: string,
): void =&gt; {
  // 实例化ScopedCSS
  if (!processor) {
    processor = new ScopedCSS();
  }
	...
	// 一些空值的处理
  const mountDOM = appWrapper;
  if (!mountDOM) {
    return;
  }

  const tag = (mountDOM.tagName || &#x27;&#x27;).toLowerCase();

  if (tag &amp;&amp; stylesheetElement.tagName === &#x27;STYLE&#x27;) {
		// 生成前缀，根元素标签名[data-qiankun=&quot;应用名&quot;]
    const prefix = `${tag}[${QiankunCSSRewriteAttr}=&quot;${appName}&quot;]`;
    processor.process(stylesheetElement, prefix);
  }
};
</code></pre>
<ul>
<li>
<p>prefix：</p>
<p><code>div[data-qiankun=&quot;react16&quot;]</code></p>
</li>
<li>
<p>stylesheetElement：</p>
</li>
</ul>
<p><img alt="Untitled" src="/assets/images/experimentalStyleIsolation3-65317c3a950bee05b9349490ba2778ae.png" width="742" height="244"></p>
<h3 id="进入processorprocess看看对它进行了什么操作">进入processor.process看看对它进行了什么操作</h3>
<pre><code class="language-tsx">// 重写样式选择器以及对于空的style节点设置MutationObserver监听，原因可能存在动态增加样式的情况
process(styleNode: HTMLStyleElement, prefix: string = &#x27;&#x27;) {
		// 当style标签有内容时进行操作
    if (styleNode.textContent !== &#x27;&#x27;) {
			// styleNode.textContent为style标签内的内容
      const textNode = document.createTextNode(styleNode.textContent || &#x27;&#x27;);
			// swapNode为创建的空的style标签
      this.swapNode.appendChild(textNode);
			// 获取样式表
      const sheet = this.swapNode.sheet as any;
			// 从样式表获取cssRules该值是标准的，把样式规则从伪数组转化成数组
      const rules = arrayify&lt;CSSRule&gt;(sheet?.cssRules ?? []);
			// 通过遍历和正则重写每个选择器的前缀
      const css = this.rewrite(rules, prefix);
			// 将处理后的重写后的css放入原来的styleNode中
      styleNode.textContent = css;
      // 清理工具人swapNode
      this.swapNode.removeChild(textNode);
      return;
    }

		//对空的样式节点进行监听，可能存在动态插入的问题
    const mutator = new MutationObserver((mutations) =&gt; {
      for (let i = 0; i &lt; mutations.length; i += 1) {
				// mutation为变更的每个记录MutationRecord
        const mutation = mutations[i];

				// 判断该节点是否应处理过
        if (ScopedCSS.ModifiedTag in styleNode) {
          return;
        }

        if (mutation.type === &#x27;childList&#x27;) {
          const sheet = styleNode.sheet as any;
          const rules = arrayify&lt;CSSRule&gt;(sheet?.cssRules ?? []);
          const css = this.rewrite(rules, prefix);

          styleNode.textContent = css;
          // 增加处理节点的标识
          (styleNode as any)[ScopedCSS.ModifiedTag] = true;
        }
      }
    });

    // 监听当前的style标签，当styleNode为空的时候，以及变更的时候，比如引入的antd样式文件
    mutator.observe(styleNode, { childList: true });
  }
</code></pre>
<p>Q1：为什么在<code>style</code>标签有内容的时候使用<code>this.swapNode</code>这个工具人，而在监听的时候不使用？</p>
<p>还记得我们是需要干什么吗？</p>
<p>改写<code>style</code>标签内的样式规则</p>
<p>因此这里就通过<code>style.sheet.cssRules</code>方式去获取style标签里的每一条规则进行重写，我们来看下<code>sheet</code>样式表的数据结构</p>
<p><img alt="Untitled" src="/assets/images/experimentalStyleIsolation4-580d70c7d6b84f1eee5ded88982be30b.png" width="1299" height="344"></p>
<p>通过这个结构我们其实下一步想要做的事情很清楚了</p>
<p>就是重写每一条<code>cssRules</code>并且通过字符串拼接赋值给<code>style</code>标签</p>
<p><img alt="Untitled" src="/assets/images/experimentalStyleIsolation5-2acf7a8bb0f4f77623e7453b1cedea5b.png" width="2754" height="504"></p>
<p>但是我们得注意两点：</p>
<ul>
<li>选择器不同我们的处理方式也不同</li>
<li>对选择器的匹配规则的处理</li>
</ul>
<h3 id="让我们看看rewrite具体进行了什么操作这里主要分为两块">让我们看看rewrite具体进行了什么操作，这里主要分为两块：</h3>
<ul>
<li>
<p>一对选择器的类型进行判断</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSRule/type">CSSRule.type</a></p>
</li>
</ul>
<pre><code class="language-tsx">private rewrite(rules: CSSRule[], prefix: string = &#x27;&#x27;) {
    let css = &#x27;&#x27;;

    rules.forEach((rule) =&gt; {
      switch (rule.type) {
	      // 普通选择器类型
        case RuleType.STYLE:
          css += this.ruleStyle(rule as CSSStyleRule, prefix);
          break;
				// @media选择器类型
        case RuleType.MEDIA:
          css += this.ruleMedia(rule as CSSMediaRule, prefix);
          break;
				// @supports选择器类型
        case RuleType.SUPPORTS:
          css += this.ruleSupport(rule as CSSSupportsRule, prefix);
          break;
        default:
          css += `${rule.cssText}`;
          break;
      }
    });

    return css;
  }
</code></pre>
<ul>
<li>二是进行正则替换</li>
</ul>
<p>特殊的</p>
<pre><code class="language-tsx">// 处理类似于@media screen and (min-width: 900px) {}
private ruleMedia(rule: CSSMediaRule, prefix: string) {
  const css = this.rewrite(arrayify(rule.cssRules), prefix);
  return `@media ${rule.conditionText} {${css}}`;
}

// 处理类似于@supports (display: grid) {}
private ruleSupport(rule: CSSSupportsRule, prefix: string) {
  const css = this.rewrite(arrayify(rule.cssRules), prefix);
  return `@supports ${rule.conditionText} {${css}}`;
}
</code></pre>
<p>普通的</p>
<pre><code class="language-tsx">// prefix为&quot;div[data-qiankun=&quot;react16&quot;]&quot;
private ruleStyle(rule: CSSStyleRule, prefix: string) {
		// 根选择器，比如body、html以及:root
    const rootSelectorRE = /((?:[^\w\-.#]|^)(body|html|:root))/gm;
		// 根组合选择器，类似于 html body{...}
    const rootCombinationRE = /(html[^\w{[]+)/gm;

		// 获取选择器
    const selector = rule.selectorText.trim();

		// 获取样式文本，比如&quot;html { font-family: sans-serif; line-height: 1.15; text-size-adjust: 100%; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }&quot;
    let { cssText } = rule;
	   // 对根选择器(body、html、:root)进行判断，替换成prefix
    if (selector === &#x27;html&#x27; || selector === &#x27;body&#x27; || selector === &#x27;:root&#x27;) {
      return cssText.replace(rootSelectorRE, prefix);
    }

    // 对于根组合选择器进行匹配
    if (rootCombinationRE.test(rule.selectorText)) {
      const siblingSelectorRE = /(html[^\w{]+)(\+|~)/gm;
			// 对于非标准的兄弟选择器转换时进行忽略，置空处理
      if (!siblingSelectorRE.test(rule.selectorText)) {
        cssText = cssText.replace(rootCombinationRE, &#x27;&#x27;);
      }
    }

    // 普通选择器匹配
    cssText = cssText.replace(/^[\s\S]+{/, (selectors) =&gt;
			// selectors为类似于.link{
      selectors.replace(/(^|,\n?)([^,]+)/g, (item, p, s) =&gt; {
				// 处理类似于div,body,span { ... }，含有根元素的
        if (rootSelectorRE.test(item)) {
          return item.replace(rootSelectorRE, (m) =&gt; {
            const whitePrevChars = [&#x27;,&#x27;, &#x27;(&#x27;];
						// 将其中的根元素替换为前缀保留,或者（
            if (m &amp;&amp; whitePrevChars.includes(m[0])) {
              return `${m[0]}${prefix}`;
            }
						// 直接把根元素替换成前缀
            return prefix;
          });
        }

        return `${p}${prefix} ${s.replace(/^ */, &#x27;&#x27;)}`;
      }),
    );

    return cssText;
  }
</code></pre>
<h3 id="动态添加样式的思考">动态添加样式的思考🤔</h3>
<p>那么通过JS动态添加的<code>style</code>、<code>link</code>或者<code>script</code>标签都是不是也需要运行在相应的<code>CSS</code>或者<code>JS</code>沙箱中呢，添加这些标签的常见方法无疑是<code>createElement</code>、<code>appendChild</code>和<code>insertBefore</code>，那其实我们只要对他们设置监听就可以了</p>
<p><code>dynamicAppend</code>就是用来解决上面的问题的，它暴露了两个方法</p>
<ul>
<li>patchStrictSandbox：QianKun JS沙箱模式的多例模式</li>
</ul>
<p><img alt="patchStrictSandbox.png" src="/assets/images/patchStrictSandbox-c6207c8d748f193c9153b1a22aa9cbba.png" width="2660" height="3020"></p>
<p><strong>patchStrictSandbox</strong></p>
<pre><code class="language-tsx">export function patchStrictSandbox(
  appName: string,
	// 返回包裹子应用的那一块Dom结构
  appWrapperGetter: () =&gt; HTMLElement | ShadowRoot,
  proxy: Window,
  mounting = true,
  scopedCSS = false,
  excludeAssetFilter?: CallableFunction,
){
  ...
let containerConfig = proxyAttachContainerConfigMap.get(proxy);
  if (!containerConfig) {
    containerConfig = {
      appName,
      proxy,
      appWrapperGetter,
      dynamicStyleSheetElements: [],
      strictGlobal: true,
      excludeAssetFilter,
      scopedCSS,
    };
		// 建立了代理对象和子应用配置信息Map关系
    proxyAttachContainerConfigMap.set(proxy, containerConfig);
  }

	// 重写Document.prototype.createElement
  const unpatchDocumentCreate = patchDocumentCreateElement();

	// 重写appendChild、insertBefore
  const unpatchDynamicAppendPrototypeFunctions = patchHTMLDynamicAppendPrototypeFunctions(
    (element) =&gt; elementAttachContainerConfigMap.has(element),
    (element) =&gt; elementAttachContainerConfigMap.get(element)!,
  );
  ...
}
</code></pre>
<ul>
<li>扩展<code>Document.prototype.createElement</code></li>
<li>扩展<code>appendChild</code>、<code>insertBefore</code></li>
</ul>
<p><strong>patchDocumentCreateElement</strong></p>
<pre><code class="language-tsx">function patchDocumentCreateElement() {
	// 记录createElement是否被重写
  const docCreateElementFnBeforeOverwrite = docCreatePatchedMap.get(document.createElement);

  if (!docCreateElementFnBeforeOverwrite) {
    const rawDocumentCreateElement = document.createElement;
		// 重写Document.prototype.createElement
    Document.prototype.createElement = function createElement&lt;K extends keyof HTMLElementTagNameMap&gt;(
      this: Document,
      tagName: K,
      options?: ElementCreationOptions,
    ): HTMLElement {
      const element = rawDocumentCreateElement.call(this, tagName, options);
			// 判断创建的是否为style、link和script标签
      if (isHijackingTag(tagName)) {
        const { window: currentRunningSandboxProxy } = getCurrentRunningApp() || {};
        if (currentRunningSandboxProxy) {
					// 获取子应用的配置信息
          const proxyContainerConfig = proxyAttachContainerConfigMap.get(currentRunningSandboxProxy);
          if (proxyContainerConfig) {
            // 建立新元素element和子应用配置的对应关系
            elementAttachContainerConfigMap.set(element, proxyContainerConfig);
          }
        }
      }

      return element;
    };

    if (document.hasOwnProperty(&#x27;createElement&#x27;)) {
			// 重写
      document.createElement = Document.prototype.createElement;
    }

    docCreatePatchedMap.set(Document.prototype.createElement, rawDocumentCreateElement);
  }
}

function isHijackingTag(tagName?: string) {
  return (
    tagName?.toUpperCase() === LINK_TAG_NAME ||
    tagName?.toUpperCase() === STYLE_TAG_NAME ||
    tagName?.toUpperCase() === SCRIPT_TAG_NAME
  );
}
</code></pre>
<ul>
<li>重写<code>document.createElement</code></li>
<li>建立新元素element和子应用配置的对应关系<code>elementAttachContainerConfigMap</code></li>
</ul>
<p><strong>patchHTMLDynamicAppendPrototypeFunctions</strong></p>
<pre><code class="language-tsx">export function patchHTMLDynamicAppendPrototypeFunctions(
  isInvokedByMicroApp: (element: HTMLElement) =&gt; boolean,
  containerConfigGetter: (element: HTMLElement) =&gt; ContainerConfig,
) {
  // 当appendChild和insertBefore没有被重写的时候
  if (
    HTMLHeadElement.prototype.appendChild === rawHeadAppendChild &amp;&amp;
    HTMLBodyElement.prototype.appendChild === rawBodyAppendChild &amp;&amp;
    HTMLHeadElement.prototype.insertBefore === rawHeadInsertBefore
  ) {
    HTMLHeadElement.prototype.appendChild = getOverwrittenAppendChildOrInsertBefore({
      rawDOMAppendOrInsertBefore: rawHeadAppendChild,
      containerConfigGetter,
      isInvokedByMicroApp,
    }) as typeof rawHeadAppendChild;
    HTMLBodyElement.prototype.appendChild = getOverwrittenAppendChildOrInsertBefore({
      rawDOMAppendOrInsertBefore: rawBodyAppendChild,
      containerConfigGetter,
      isInvokedByMicroApp,
    }) as typeof rawBodyAppendChild;

    HTMLHeadElement.prototype.insertBefore = getOverwrittenAppendChildOrInsertBefore({
      rawDOMAppendOrInsertBefore: rawHeadInsertBefore as any,
      containerConfigGetter,
      isInvokedByMicroApp,
    }) as typeof rawHeadInsertBefore;
  }}
</code></pre>
<ul>
<li>当appendChild、appendChild和insertBefore没有被重写的时候进行重写</li>
</ul>
<p>getOverwrittenAppendChildOrInsertBefore</p>
<pre><code class="language-tsx">function getOverwrittenAppendChildOrInsertBefore(opts: {
  rawDOMAppendOrInsertBefore: &lt;T extends Node&gt;(newChild: T, refChild?: Node | null) =&gt; T;
  isInvokedByMicroApp: (element: HTMLElement) =&gt; boolean;
  containerConfigGetter: (element: HTMLElement) =&gt; ContainerConfig;
}) {
  return function appendChildOrInsertBefore&lt;T extends Node&gt;(
    this: HTMLHeadElement | HTMLBodyElement,
    newChild: T,
    refChild: Node | null = null,
  ) {
    let element = newChild as any;
    const { rawDOMAppendOrInsertBefore, isInvokedByMicroApp, containerConfigGetter } = opts;
    // 当不是style、link或者是script标签的时候或者在元素的创建找不到对应的子应用配置信息时，走原生的方法
    if (!isHijackingTag(element.tagName) || !isInvokedByMicroApp(element)) {
      return rawDOMAppendOrInsertBefore.call(this, element, refChild) as T;
    }

    if (element.tagName) {
      // 获取当前子应用的配置信息
      const containerConfig = containerConfigGetter(element);
      const {
        appName,
        appWrapperGetter,
        proxy,
        strictGlobal,
        dynamicStyleSheetElements,
        scopedCSS,
        excludeAssetFilter,
      } = containerConfig;

      switch (element.tagName) {
        case LINK_TAG_NAME:
        case STYLE_TAG_NAME: {
          let stylesheetElement: HTMLLinkElement | HTMLStyleElement = newChild as any;
          const { href } = stylesheetElement as HTMLLinkElement;
          // 配置项不需要被劫持的资源
          if (excludeAssetFilter &amp;&amp; href &amp;&amp; excludeAssetFilter(href)) {
            return rawDOMAppendOrInsertBefore.call(this, element, refChild) as T;
          }

          // 挂载的dom结构，即子应用的dom结构
          const mountDOM = appWrapperGetter();

          // 如果开启了实验性的样式沙箱模式
          if (scopedCSS) {
            // exclude link elements like &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt;
            const linkElementUsingStylesheet =
              element.tagName?.toUpperCase() === LINK_TAG_NAME &amp;&amp;
              (element as HTMLLinkElement).rel === &#x27;stylesheet&#x27; &amp;&amp;
              (element as HTMLLinkElement).href;
            // 对于link标签进行样式资源下载，并进行样式的重写
            if (linkElementUsingStylesheet) {
              const fetch =
                typeof frameworkConfiguration.fetch === &#x27;function&#x27;
                  ? frameworkConfiguration.fetch
                  : frameworkConfiguration.fetch?.fn;
              stylesheetElement = convertLinkAsStyle(
                element,
                (styleElement) =&gt; css.process(mountDOM, styleElement, appName),
                fetch,
              );
              dynamicLinkAttachedInlineStyleMap.set(element, stylesheetElement);
            } else {
              css.process(mountDOM, stylesheetElement, appName);
            }
          }

          // 重写以后的style标签
          dynamicStyleSheetElements.push(stylesheetElement);
          const referenceNode = mountDOM.contains(refChild) ? refChild : null;
          return rawDOMAppendOrInsertBefore.call(mountDOM, stylesheetElement, referenceNode);
        }
	...
}
</code></pre>
<ul>
<li>patchLooseSandbox：QianKun JS沙箱模式的单例模式和快照模式下</li>
</ul>
<p><img alt="patchLooseSandbox.png" src="/assets/images/patchLooseSandbox-2b54fc301c0f3f3b0c4e71b965825f0c.png" width="2660" height="2522"></p>
<pre><code class="language-tsx">export function patchLooseSandbox(
  appName: string,
  appWrapperGetter: () =&gt; HTMLElement | ShadowRoot,
  proxy: Window,
  mounting = true,
  scopedCSS = false,
  excludeAssetFilter?: CallableFunction,
): Freer {
  let dynamicStyleSheetElements: Array&lt;HTMLLinkElement | HTMLStyleElement&gt; = [];

  const unpatchDynamicAppendPrototypeFunctions = patchHTMLDynamicAppendPrototypeFunctions(
    // 判断当前微应用是否运行
		() =&gt; checkActivityFunctions(window.location).some((name) =&gt; name === appName),
    // 返回微应用的配置信息
		() =&gt; ({
      appName,
      appWrapperGetter,
      proxy,
      strictGlobal: false,
      scopedCSS,
      dynamicStyleSheetElements,
      excludeAssetFilter,
    }),
  );
}
</code></pre>
<p>由于是单例模式修改的还是全局的window去掉了对<code>document.createElement</code>的重写，不需要建立微应用和新建元素的一一对应</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/micfrontend/practice/communication"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">communication</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/micfrontend/深入理解QianKun/JS SandBox/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">JS SandBox</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#css-in-js" class="table-of-contents__link toc-highlight">CSS in JS</a><ul><li><a href="#优缺点" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#样式约定" class="table-of-contents__link toc-highlight">样式约定</a><ul><li><a href="#优缺点-1" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#预处理器" class="table-of-contents__link toc-highlight">预处理器</a><ul><li><a href="#优缺点-2" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#css-module" class="table-of-contents__link toc-highlight">CSS Module</a><ul><li><a href="#优缺点-3" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#shadow-dom" class="table-of-contents__link toc-highlight">Shadow DOM</a><ul><li><a href="#问题" class="table-of-contents__link toc-highlight">问题：</a></li><li><a href="#优缺点-4" class="table-of-contents__link toc-highlight">优缺点</a></li></ul></li><li><a href="#strictstyleisolation" class="table-of-contents__link toc-highlight">strictStyleIsolation</a><ul><li><a href="#registermicroapps注册子应用" class="table-of-contents__link toc-highlight"><strong><strong>registerMicroApps：注册子应用</strong></strong></a></li><li><a href="#loadapp加载子应用" class="table-of-contents__link toc-highlight">loadApp：加载子应用</a></li><li><a href="#createelement添加shadow-dom" class="table-of-contents__link toc-highlight">createElement：添加shadow dom</a></li></ul></li><li><a href="#experimentalstyleisolation" class="table-of-contents__link toc-highlight">experimentalStyleIsolation</a><ul><li><a href="#createelement给最外层增加data-qiankun属性并且获取所有style标签" class="table-of-contents__link toc-highlight">createElement：给最外层增加data-qiankun属性，并且获取所有style标签</a></li><li><a href="#cssprocess详细处理" class="table-of-contents__link toc-highlight">css.process详细处理</a></li><li><a href="#进入processorprocess看看对它进行了什么操作" class="table-of-contents__link toc-highlight">进入processor.process看看对它进行了什么操作</a></li><li><a href="#让我们看看rewrite具体进行了什么操作这里主要分为两块" class="table-of-contents__link toc-highlight">让我们看看rewrite具体进行了什么操作，这里主要分为两块：</a></li><li><a href="#动态添加样式的思考" class="table-of-contents__link toc-highlight">动态添加样式的思考🤔</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Social</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://twitter.com/battleofplassey" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://instagram.com/battleofplassey" target="_blank" rel="noopener noreferrer" class="footer__link-item">Instagram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Navigation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">Home</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/whoami">Stuff of Legend</a></li><li class="footer__item"><a href="https://github.com/battleofplassey" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">other Projects</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://sidtoons.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">SidToons.com<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://vocab.js.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">vocab.js.org<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://tldr.palashsh.me/" target="_blank" rel="noopener noreferrer" class="footer__link-item">TL;DR News<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="/img/blogasaurus_secondary.svg" alt="Zaoei Logo" class="footer__logo themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/blogasaurus_secondary.svg" alt="Zaoei Logo" class="footer__logo themedComponent_mlkZ themedComponent--dark_xIcU"></div><div class="footer__copyright">Copyright © 2024 Blogasaurus by Palash Shrivastava.</div></div></div></footer></div>
</body>
</html>